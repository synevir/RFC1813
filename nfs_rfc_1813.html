<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<!--This file was converted to xhtml by LibreOffice - see https://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.-->

<head profile="http://dublincore.org/documents/dcmi-terms/">

    <title xml:lang="en-US"> NFS 3 (RFC-1813)</title>

    <style>
        table {
            border-collapse: collapse;
            border-spacing: 0;
            empty-cells: show
        }

        td,
        th {
            vertical-align: top;
            font-size: 12pt;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            clear: both;
        }

        ol,
        ul {
            margin: 0;
            padding: 0;
        }

        li {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        span.footnodeNumber {
            padding-right: 1em;
        }

        span.annotation_style_by_filter {
            font-size: 95%;
            font-family: Arial;
            background-color: #fff000;
            margin: 0;
            border: 0;
            padding: 0;
        }

        span.heading_numbering {
            margin-right: 0.8rem;
        }

        * {
            margin: 0;
        }

        .P1 {
            font-size: 12pt;
            margin-bottom: 0in;
            margin-top: 0in;
            font-family: 'Liberation Mono';
            writing-mode: horizontal-tb;
            direction: ltr;
        }

        .P2 {
                font-size: 13pt;
            margin-bottom: 0in;
               margin-top: 0in;
              font-family: 'Liberation Mono';
             writing-mode: horizontal-tb;
                direction: ltr;
              font-weight: bold;
        }

        .P3 {
            font-size: 12pt;
            margin-bottom: 0in;
            margin-top: 0in;
            font-family: 'Liberation Mono';
            writing-mode: horizontal-tb;
            direction: ltr;
        }

        .P4 {
            font-size: 11pt;
            margin-bottom: 0in;
            margin-top: 0in;
            font-family: 'Liberation Mono';
            writing-mode: horizontal-tb;
            direction: ltr;
            font-weight: bold;
        }

        .Pr_20_Text {
            font-size: 10pt;
            font-family: 'Liberation Mono';
            writing-mode: horizontal-tb;
            direction: ltr;
            margin-top: 0in;
            margin-bottom: 0in;
        }

        /* ODF styles with no properties representable as CSS:
     { } */
    </style>
</head>

<body dir="ltr" style="max-width:8.2681in;margin-top:0.2in; margin-bottom:0.7874in; margin-left:0.7in; margin-right:0.7874in; ">
    <p class="Pr_20_Text">Network Working Group                                       B. Callaghan</p>
    <p class="Pr_20_Text">Request for Comments: 1813                                  B. Pawlowski</p>
    <p class="Pr_20_Text">Category: Informational                                      P. Staubach</p>
    <p class="Pr_20_Text">                                                  Sun Microsystems, Inc.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">RFC 1813                 NFS Version 3 Protocol                June 1995</p>
    <p class="Pr_20_Text"><a href="https://www.rfc-editor.org/rfc/rfc1813"> https://www.rfc-editor.org/rfc/rfc1813</a> </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">RFC 1813          Специфікація протоколу NFS версії 3       Червень 1995</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">Статус цього Меморандуму</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Ця пам'ятка містить інформацію для Інтернет-спільноти. Цей меморандум не визначає будь-який стандарт Інтернету. Розповсюдження цієї пам'ятки необмежено.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">Примітка IESG</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Коментар Керівної групи з розробки Інтернету: зверніть увагу, що IETF не бере участі у створенні або підтримці цієї специфікації. Це означає, що специфікація не відповідає стандартам.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">Анотація</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    У цьому документі описано протокол NFS версії 3. Ця стаття надається для того, щоб люди могли писати сумісні реалізації.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <p class="P4">Зміст</p>
    <p class="Pr_20_Text"> </p>
    <p class="P3">   <a href="#section_1">1.</a>  Вступ  </p>
    <p class="Pr_20_Text">      <a href="#section_1.1">1.1</a> Сфера застосування протоколу NFS версії 3 </p>
    <p class="Pr_20_Text">      <a href="#section_1.2">1.2</a> Корисні терміни</p>
    <p class="Pr_20_Text">      <a href="#section_1.3">1.3</a> Віддалений виклик процедури</p>
    <p class="Pr_20_Text">      <a href="#section_1.4">1.4</a> Представлення зовнішніх даних </p>
    <p class="Pr_20_Text">      <a href="#section_1.5">1.5</a> Автентифікація та перевірка дозволів </p>
    <p class="Pr_20_Text">      <a href="#section_1.6">1.6</a> Філософія </p>
    <p class="Pr_20_Text">      <a href="#section_1.7">1.7</a> Зміни порівняно з протоколом NFS версії 2 </p>
    <p class="Pr_20_Text"> </p>
    <p class="P3">   <a href="#section_2">2.</a> Інформація RPC</p>
    <p class="Pr_20_Text">      <a href="#section_2.1">2.1</a> Автентифікація</p>
    <p class="Pr_20_Text">      <a href="#section_2.2">2.2</a> Константи </p>
    <p class="Pr_20_Text">      <a href="#section_2.3">2.3</a> Транспортна адреса </p>
    <p class="Pr_20_Text">      <a href="#section_2.4">2.4</a> Розміри </p>
    <p class="Pr_20_Text">      <a href="#section_2.5">2.5</a> Основні типи даних</p>
    <p class="Pr_20_Text">      <a href="#section_2.6">2.6</a> Визначені номери помилок </p>
    <p class="Pr_20_Text"> </p>
    <p class="P3">   <a href="#section_3">3.</a> Процедури сервера</p>
    <p class="Pr_20_Text">      <a href="#section_3.1">3.1</a> Загальні коментарі щодо атрибутів</p>
    <p class="Pr_20_Text">      <a href="#section_3.2">3.2</a> Загальні коментарі щодо імен файлів </p>
    <p class="Pr_20_Text">      <a href="#section_3.3.0">3.3.0</a> NULL: Нічого не робити</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.1">3.3.1</a> GETATTR: отримати атрибути файлу</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.2">3.3.2</a> SETATTR: встановити атрибути файлу</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.3">3.3.3</a> LOOKUP: пошук імені файлу</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.4">3.3.4</a> ACCESS: перевірка дозвола доступу</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.5">3.3.5</a> READLINK: читання з символічного посилання</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.6">3.3.6</a> READ: читання з файлу</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.7">3.3.7</a> WRITE: запис у файл</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.8">3.3.8</a> CREATE: створити файл</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.9">3.3.9</a> MKDIR:  cтворення каталогу</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.10">3.3.10</a> SYMLINK: cтворити символічне посилання</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.11">3.3.11</a> MKNOD: створити спеціальний пристрій</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.12">3.3.12</a> REMOVE: видалити файл</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.13">3.3.13</a> RMDIR: видалити каталог</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.14">3.3.14</a> RENAME: перейменувати файл або каталог</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.15">3.3.15</a> LINK: створити посилання на об’єкт</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.16">3.3.16</a> READDIR: читання з каталогу</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.17">3.3.17</a> READDIRPLUS: розширене читання з каталогу</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.18">3.3.18</a> FSSTAT: отримати динамічну інформацію про файлову систему</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.19">3.3.19</a> FSINFO: отримати статичну інформацію про файлову систему</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.20">3.3.20</a> PATHCONF: отримати інформацію POSIX</p>
    <p class="Pr_20_Text">      <a href="#section_3.3.21">3.3.21</a> COMMIT: фіксація кешованих даних на сервері до стабільного сховища</p>
    <p class="Pr_20_Text"> </p>
    <p class="P3">   <a href="#section_4">4.</a> Проблеми реалізації</p>
    <p class="Pr_20_Text">      <a href="#section_4.1">4.1</a> Підтримка кількох версій</p>
    <p class="Pr_20_Text">      <a href="#section_4.2">4.2</a> Взаємодія сервер/клієнт</p>
    <p class="Pr_20_Text">      <a href="#section_4.3">4.3</a> Інтерпретація імені шляху </p>
    <p class="Pr_20_Text">      <a href="#section_4.4">4.4</a> Проблеми з дозволами </p>
    <p class="Pr_20_Text">      <a href="#section_4.5">4.5</a> Дубльований кеш запитів</p>
    <p class="Pr_20_Text">      <a href="#section_4.6">4.6</a> Обробка компонента імені файлу</p>
    <p class="Pr_20_Text">      <a href="#section_4.7">4.7</a> Синхронні операції модифікації</p>
    <p class="Pr_20_Text">      <a href="#section_4.8">4.8</a> Стабільне зберігання </p>
    <p class="Pr_20_Text">      <a href="#section_4.9">4.9</a> Пошук і розпізнавання імен</p>
    <p class="Pr_20_Text">      <a href="#section_4.10">4.10</a> Адаптивна ретрансляція</p>
    <p class="Pr_20_Text">      <a href="#section_4.11">4.11</a> Політика кешування</p>
    <p class="Pr_20_Text">      <a href="#section_4.12">4.12</a> Стабільний запис проти нестабільного</p>
    <p class="Pr_20_Text">      <a href="#section_4.13">4.13</a> 32-розрядні клієнти/сервери та 64-розрядні клієнти/сервери</p>
    <p class="Pr_20_Text"> </p>
    <p class="P3">   <a href="#section_5">5.</a> Додаток I: Протокол монтування</p>
    <p class="Pr_20_Text">      <a href="#section_5.1">5.1</a> Інформація RPC </p>
    <p class="Pr_20_Text">         <a href="#section_5.1.1">5.1.1</a> Автентифікація </p>
    <p class="Pr_20_Text">         <a href="#section_5.1.2">5.1.2</a> Константи </p>
    <p class="Pr_20_Text">         <a href="#section_5.1.3">5.1.3</a> Транспортна адреса </p>
    <p class="Pr_20_Text">         <a href="#section_5.1.4">5.1.4</a> Розміри</p>
    <p class="Pr_20_Text">         <a href="#section_5.1.5">5.1.5</a> Основні типи даних </p>
    <p class="Pr_20_Text">      <a href="#section_5.2">5.2</a> Серверні процедури </p>
    <p class="Pr_20_Text">         <a href="#section_5.2.0">5.2.0</a> NULL: Нічого не робити</p>
    <p class="Pr_20_Text">         <a href="#section_5.2.1">5.2.1</a> MNT: Додати запис монтування</p>
    <p class="Pr_20_Text">         <a href="#section_5.2.2">5.2.2</a> DUMP: Повернення записів монтування</p>
    <p class="Pr_20_Text">         <a href="#section_5.2.3">5.2.3</a> UMNT: Видалити запис монтування</p>
    <p class="Pr_20_Text">         <a href="#section_5.1.1">5.2.4</a> UMNTALL: Видалити усі записи монтування</p>
    <p class="Pr_20_Text">         <a href="#section_5.2.5">5.2.5</a> ЕКСПОРТ: Повернути список експорту</p>
    <p class="Pr_20_Text"> </p>
    <p class="P3">   <a href="#section_6">6.</a> Додаток II: Протокол менеджера блокувань</p>
    <p class="Pr_20_Text">      <a href="#section_6.1">6.1</a> Інформація RPC </p>
    <p class="Pr_20_Text">         <a href="#section_6.1.1">6.1.1</a> Автентифікація </p>
    <p class="Pr_20_Text">         <a href="#section_6.1.2">6.1.2</a> Константи </p>
    <p class="Pr_20_Text">         <a href="#section_6.1.3">6.1.3</a> Транспортна адреса </p>
    <p class="Pr_20_Text">         <a href="#section_6.1.4">6.1.4</a> Основні типи даних </p>
    <p class="Pr_20_Text">      <a href="#section_6.2">6.2</a> Процедури NLM </p>
    <p class="Pr_20_Text">         <a href="#section_6.2">6.2</a> NULL: Нічого не робити</p>
    <p class="Pr_20_Text">      <a href="#section_6.3">6.3</a> Проблеми впровадження </p>
    <p class="Pr_20_Text">         <a href="#section_6.3.1">6.3.1</a> 64-розрядні зсуви та довжини </p>
    <p class="Pr_20_Text">         <a href="#section_6.3.2">6.3.2</a> Файлові дескриптори </p>
    <p class="Pr_20_Text"> </p>
    <p class="P3">   <a href="#section_7">7.</a> Додаток III: Бібліографія</p>
    <p class="Pr_20_Text"> </p>
    <p class="P3">   <a href="#section_8">8.</a> Міркування щодо безпеки </p>
    <p class="Pr_20_Text"> </p>
    <p class="P3">   <a href="#section_9">9.</a> Подяки</p>
    <p class="Pr_20_Text"> </p>
    <p class="P3">   <a href="#section_10">10.</a> Адреси авторів</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <hr>
    <p class="Pr_20_Text"> </p>
    
    
    
    <p class="P2" id="section_1">1. Вступ </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Протокол NFS компанії Sun забезпечує прозорий віддалений доступ до спільних файлових систем у мережах. Протокол NFS розроблено таким чином, щоб не залежати від машини, операційної системи, архітектури мережі та транспортного протоколу. Ця незалежність досягається завдяки використанню примітивів Remote Procedure Call (RPC), створених на основі зовнішнього представлення даних (XDR). Реалізації протоколу NFS версії 2 існують для різноманітних машин, від персональних комп’ютерів до суперкомп’ютерів. Початкова версія протоколу NFS вказана в Специфікації протоколу мережевої файлової системи [RFC1094]. Опис початкової реалізації можна знайти в [Sandberg].</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Підтримуваний протокол MOUNT виконує специфічні для операційної системи функції, які дозволяють клієнтам приєднувати віддалені дерева каталогів до точки у локальній файловій системі. Процес монтування також дозволяє серверу надавати привілеї віддаленого доступу обмеженому набору клієнтів через контроль експорту.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Менеджер блокувань забезпечує підтримку блокування файлів у середовищі NFS. Протокол Менеджера блокування мережі (NLM) виокремлює властиві аспекти блокування файлів зі збереженням стану в окремий протокол.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Повний опис наведених вище протоколів і їх реалізації можна знайти в [X/OpenNFS].</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Метою цього документа є:</p>
    <p class="Pr_20_Text">         o Визначення протокола NFS версії 3.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">         o Описати семантику протоколу за допомогою анотації, та опис запланованого впровадження.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">         o Визначення протоколу MOUNT версії 3.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">         o Короткий опис зміни між протоколом NLM версії 3 і протоколом NLM версії 4.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Нормативний текст – це опис процедур RPC, аргументів і результатів, який визначає мережевий протокол зв’язку та семантику цих процедур. Матеріал, що описує практику впровадження, допомагає зрозуміти специфікацію протоколу та описує деякі можливі проблеми впровадження та їх вирішення. Неможливо описати всі реалізації, тому для надання прикладів найчастіше використовується реалізація протоколу NFS версії 3 в операційній системі UNIX. Враховуючи це, обговорення реалізації не має повноважень щодо опису самого мережевого протоколу зв’язку.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    
    
    <p class="P3" id="section_1.1">1.1 Сфера застосування протоколу NFS версії 3</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Ця ревізія протоколу NFS відповідає новим вимогам. Необхідність підтримки більших файлів і файлових систем спонукала розширення, яке дозволяє 64-бітні розміри файлів і зміщення. Редакція покращує безпеку, додаючи підтримку для перевірки доступу, яка виконується на сервері. Модифікації продуктивності бувають трьох типів:</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    1. Кількість мережевих пакетів для заданого набору файлових операцій зменшується шляхом повернення атрибутів файлу під час кожної операції, таким чином зменшуючи кількість викликів для отримання змінених атрибутів.
    </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    2. Вузьке місце запису, викликане синхронним визначенням запису в протоколі NFS версії 2, було усунено шляхом додавання підтримки можливості виконання сервером NFS небезпечного запису. Небезпечні записи – це записи, які не були зафіксовані в стабільному сховищі до операції повернення. Ця специфікація визначає метод для надійного внесення цих небезпечних записів до стабільного сховища.</p>
    <br>
    <p class="Pr_20_Text">    3. Обмеження на розміри передач послаблено. Можливість підтримувати декілька версій протоколу в RPC дозволить реалізації протоколу NFS версії 3 визначати клієнтів та сервери, які забезпечують зворотню сумісність із існуючою встановленою базою реалізацій протоколу NFS версії 2.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Розширення, описані тут, являють собою еволюцію існуючого протоколу NFS, і більшість конструктивних особливостей протоколу NFS, описаних у [Sandberg], зберігаються. Дивіться Зміни протоколу NFS версії 2 для більш детального підсумку змін, внесених цією версією.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    
    
    <p class="P3" id="section_1.2">1.2 Корисні терміни</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    У цій специфікації «сервер» — це машина, яка надає ресурси мережі; «клієнт» — це машина, яка отримує доступ до ресурсів через мережу; "користувач" - це особа, яка увійшла в систему клієнта; "програма" - це програма, яка виконується на клієнті.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    
    
    <p class="P3" id="section_1.3">1.3 Віддалений виклик процедури</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Специфікація Sun Remote Procedure Call  забезпечує процедурно-орієнтований інтерфейс для віддалених служб. Кожен сервер надає програму, яка є набором процедур. Служба NFS є однією з таких програм. Комбінація адреси хоста, номера програми, номера версії та номера процедури визначає одну процедуру віддаленого обслуговування. Сервери можуть підтримувати кілька версій програми, використовуючи різні номери версій протоколу.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Протокол NFS був розроблений таким чином, щоб не вимагати будь-якого конкретного рівня надійності від його нижчих рівнів, тому його потенційно можна використовувати на багатьох основних транспортних протоколах. Сервіс NFS заснований на RPC, який забезпечує абстракцію вище рівня мережі та транспортних протоколів.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    У решті цього документа передбачається, що середовище NFS реалізоване поверх Sun RPC, яке зазначено в [RFC1057]. Повне обговорення можна знайти в [Corbin].</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    
    
    <p class="P3" id="section_1.4">1.4 Представлення зовнішніх даних</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Специфікація eXternal Data Representation (XDR) забезпечує стандартний спосіб представлення набору типів даних у мережі. Це вирішує проблему різних порядків байтів, вирівнювання структури та представлення типів даних на різних машинах, що спілкуються.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    У цьому документі мова опису даних RPC використовується для визначення параметрів формату XDR і результатів для кожної процедури служби RPC, яку надає сервер NFS. Мова опису даних RPC подібна до декларацій у мові програмування C. Додано кілька нових конструкцій.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Нотація:</p>
    <p class="Pr_20_Text">       string  name[SIZE];</p>
    <p class="Pr_20_Text">       string  data&lt;DSIZE&gt;;</p>
    <p class="Pr_20_Text">визначає ім'я, яке є блоком фіксованого розміру SIZE байтів, і дані, які є блоком змінного розміру до DSIZE байт. Ця нотація вказує на масиви
        фіксованої довжини та масиви зі змінною кількістю елементів до фіксованого максимуму. Визначення змінної довжини без указаного розміру означає відсутність максимального розміру для поля.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Визначення об'єднання яке відрізняється (discriminated union):</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      union example switch (enum status) {</p>
    <p class="Pr_20_Text">           case OK:</p>
    <p class="Pr_20_Text">              struct {</p>
    <p class="Pr_20_Text">                 filename      file1;</p>
    <p class="Pr_20_Text">                 filename      file2;</p>
    <p class="Pr_20_Text">                 integer       count;</p>
    <p class="Pr_20_Text">              }</p>
    <p class="Pr_20_Text">           case ERROR:</p>
    <p class="Pr_20_Text">              struct {</p>
    <p class="Pr_20_Text">                 errstat       error;</p>
    <p class="Pr_20_Text">                 integer       errno;</p>
    <p class="Pr_20_Text">              }</p>
    <p class="Pr_20_Text">           default:</p>
    <p class="Pr_20_Text">              void;</p>
    <p class="Pr_20_Text">      }</p>
    <p class="Pr_20_Text">   визначає структуру, де першим у мережі є тип enumeration під назвою status. Якщо значення status є OК, наступним у мережі буде структура, яка містить file1, file2 і count. Інакше, якщо значення status дорівнює ERROR, наступним у мережі буде структура, що містить error та errno. Якщо значення статусу є ні OK, ні ERROR, то в структурі більше немає даних (void).</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Тип XDR, hyper, є 8 байт (64 біти). Він використовується так само, як цілочисельний тип. Наприклад:</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      hyper          foo;</p>
    <p class="Pr_20_Text">      unsigned hyper bar;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   foo — 8-байтове значення зі знаком, а bar — 8-байтове значення без знаку.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Хоча компілятори RPC/XDR існують для генерування заглушок клієнта та сервера з вхідних даних мови опису даних RPC, реалізації NFS не потребують їх використання. Будь-яке програмне забезпечення, яке забезпечує кодування та декодування, еквівалентне канонічному мережевому порядку даних, визначеному XDR, можна використовувати для взаємодії з іншими реалізаціями NFS.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    XDR описано в [RFC1014].</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    
    
    <p class="P3" id="section_1.5">1.5 Автентифікація та перевірка дозволів</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Протокол RPC містить слот для параметрів автентифікації під час кожного виклику. Вміст параметрів автентифікації визначається типом автентифікації, що використовується сервером і клієнтом. Сервер може підтримувати кілька різних варіантів автентифікації одночасно. Тип AUTH_NONE забезпечує нульову автентифікацію, тобто інформація про автентифікацію не передається. Тип AUTH_UNIX забезпечує ідентифікатор користувача, ідентифікатор групи та групи в стилі UNIX під час кожного виклику. Тип AUTH_DES надає параметри автентифікації, зашифровані за допомогою DES, на основі загальномережевого імені з обміном ключами сеансу через схему відкритого ключа. Тип AUTH_KERB надає параметри автентифікації, зашифровані DES на основі загальномережевого імені з ключами сеансу, обмінюваними через секретні ключі Kerberos.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Сервер NFS перевіряє дозволи, беручи облікові дані з інформації автентифікації RPC у кожному віддаленому запиті. Наприклад, використовуючи різновид автентифікації AUTH_UNIX, сервер отримує effective user ID, effective group ID та групи під час кожного виклику та використовує їх для
        перевірки доступу. Використання ідентифікаторів користувачів і ідентифікаторів груп означає, що клієнт і сервер або використовують один і той же список ідентифікаторів, або виконують локальне співставлення ідентифікаторів користувача та групи. Сервер та клієнт повинні узгодити відображення від користувача до uid і від групи до gid для тих сайтів, які не реалізують послідовний простір ідентифікатора користувача та групи. На практиці таке відображення зазвичай виконується на сервері відповідно до схеми статичної відповідності або відповідності, встановленої користувачем від клієнта під час монтування.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Стиль автентифікації AUTH_DES і AUTH_KERB базується на загальномережному імені. Він забезпечує більшу безпеку завдяки використанню шифрування DES і відкритих ключів у випадку AUTH_DES, а також шифрування DES і секретних ключів Kerberos (та tickets) у випадку AUTH_KERB. Знову ж таки, сервер і клієнт повинні узгодити ідентичність конкретного імені в мережі, але відповідність імені в ідентифікаторі більше не залежить від операційної системи, так як відповідність uid і gid в AUTH_UNIX. Крім того, оскільки параметри автентифікації зашифровані, зловмисник повинен знати мережевий пароль або закритий ключ іншого користувача, щоб маскуватися під цього користувача. Так само сервер повертає верифікатор, який також зашифрований, тому для маскування під сервер потрібно знати мережевий пароль.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    Процедура NULL зазвичай не вимагає аутентифікації.</p>
    <p class="Pr_20_Text"> </p>
    
    
    <p class="P3" id="section_1.6">1.6 Філософія</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Ця специфікація визначає протокол NFS версії 3, який є мережевим протоколом зв’язку, за допомогою якого клієнт отримує доступ до сервера. Протокол забезпечує чітко визначений інтерфейс до файлових ресурсів сервера. Клієнт або сервер реалізує протокол і забезпечує відображення семантики та дій локальної файлової системи в ті, що визначені в протоколі NFS версії 3. Реалізації можуть відрізнятися різним ступенем залежно від того, якою мірою дане середовище може підтримувати всі операції та семантику, визначені в протоколі NFS версії 3. Хоча реалізації існують і використовуються для ілюстрації різних аспектів протоколу NFS версії 3, сама специфікація протоколу є остаточним описом того, як клієнти отримують доступ до ресурсів сервера.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Оскільки протокол NFS версії 3 розроблений як незалежний від операційної системи, він не обов’язково відповідає семантиці будь-якої існуючої системи. Очікується, що серверні реалізації докладатимуть усіх зусиль для підтримки протоколу. Якщо сервер не підтримує певну процедуру протоколу, він може повернути помилку NFS3ERR_NOTSUP, яка вказує на те, що операція не підтримується. Наприклад, багато операційних систем не підтримують поняття hard link. Сервер, який не підтримує жорсткі посилання, повинен повернути NFS3ERR_NOTSUP у відповідь на запит LINK. FSINFO описує процедури, які найчастіше не підтримуються, у бітовій карті властивостей. Крім того, сервер може не підтримувати певну операцію, але може емулювати її в реалізації протоколу NFS версії 3 для забезпечення більшої функціональності.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   У деяких випадках сервер може підтримувати більшість семантики, описаної протоколом, але не всю. Наприклад, поле ctime у структурі fattr вказує час останньої зміни атрибутів файлу. Багато систем не зберігають цю інформацію. У цьому випадку замість того, щоб не підтримувати операцію GETATTR, сервер може імітувати її, повертаючи останній змінений час замість ctime. Сервери повинні бути обережними під час моделювання інформації про атрибути через можливі побічні ефекти для клієнтів. Наприклад, багато клієнтів використовують час модифікації файлу як основу для своєї схеми узгодженості кешу</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Сервери NFS тупі, а клієнти NFS розумні. Саме клієнти виконують роботу, необхідну для перетворення узагальненого доступу до файлів, який надають сервери, у метод доступу до файлів, корисний для програм і користувачів. У прикладі LINK, наведеному вище, клієнт UNIX, який отримав помилку NFS3ERR_NOTSUP від сервера, виконає відновлення, необхідне для того, щоб програма виглядала так, ніби запит на зв’язування виконано успішно, або повернула зрозумілу помилку. Загалом, відновлення є зобовʼязанням клієнта.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Протокол NFS версії 3 передбачає реалізацію сервера без збереження стану (stateless). Відсутність стану (stateless) означає, що серверу не потрібно підтримувати стан будь-якого зі своїх клієнтів, щоб функціонувати належним чином. Сервери без збереження стану мають явну перевагу перед серверами зі збереженням стану у разі збою. З серверами без збереження стану клієнту потрібно лише повторити запит, доки сервер не відповість; клієнту навіть не потрібно знати, що на сервері стався збій. Дивись додаткові коментарі Дублікати запитів в кеш-пам’яті</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Щоб сервер був корисним, він зберігає незмінний стан: дані зберігаються у файловій системі. Проектні припущення в протоколі NFS 3 щодо фіксації змінених даних у стабільне сховище зменшують кількість режимів збоїв, у яких може статися втрата даних. Таким чином, реалізації протоколу NFS версії 3 можуть допускати тимчасові збої, включаючи тимчасові збої в мережі. Загалом серверні реалізації протоколу NFS версії 3 не можуть допускати постійні збої самого стабільного сховища. Однак існують відмовостійкі реалізації, які намагаються вирішити такі проблеми.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Це не означає, що сервер протоколу NFS версії 3 не може підтримувати некритичний стан. У багатьох випадках сервери будуть підтримувати стан (кеш) попередніх операцій для підвищення продуктивності. Наприклад, клієнтський запит READ може ініціювати попереднє читання наступного блоку файлу в кеші даних сервера в очікуванні того, що клієнт виконує послідовне читання, і наступний клієнтський запит READ буде задоволено з кешу даних сервера, а не з диска. Попереднє читання на сервері підвищує продуктивність завдяки overlaping вводу/виводу диска сервера запитами клієнта. Важливим моментом тут є те, що блок читання не є необхідним для правильної поведінки сервера. Якщо сервер виходить з ладу та втрачає кеш пам’яті буферів читання, відновлення буде простим після перезавантаження – клієнти продовжуватимуть операції читання, отримуючи дані з диска сервера.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Більшість операцій зі змінення даних у протоколі NFS є синхронними. Тобто, коли процедура модифікації даних повертається до клієнта, клієнт може вважати, що операція завершена, і будь-які змінені дані, пов’язані із запитом, тепер у стабільному сховищі. Наприклад, синхронний клієнтський запит WRITE може змусити сервер оновити блоки даних, блоки інформації про файлову систему та інформацію про атрибути файлу - остання інформація зазвичай називається метаданими. Після завершення операції WRITE клієнт може вважати, що дані запису у безпеці і відкинути їх. Це дуже важлива частина сервера без збереження стану. Якби сервер не скидав брудні дані в стабільне сховище перед поверненням до клієнта, клієнт не міг би дізнатися, коли змінені дані безпечно скинуті. Наступні процедури модифікації даних є синхронними: WRITE (з прапорцем стабільності, встановленим на FILE_SYNC), CREATE, MKDIR, SYMLINK, MKNOD, REMOVE, RMDIR, RENAME, LINK і COMMIT.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Протокол NFS версії 3 забезпечує безпечний асинхронний запис на сервері, коли процедура WRITE використовується разом із процедурою COMMIT. Процедура COMMIT надає клієнту спосіб скинути дані з попередніх асинхронних запитів WRITE на сервері до
        стабільного сховища та визначити, чи потрібно повторно передавати дані. Дивиться опис процедур WRITE на сторінці 49 і COMMIT на сторінці 92.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Процедура LOOKUP використовується клієнтом для перегляду багатокомпонентних імен файлів (шляхів). Кожен виклик LOOKUP використовується для визначення одного сегмента шляху. Є дві причини для обмеження LOOKUP одним сегментом: важко стандартизувати загальний формат для ієрархічних імен файлів, і клієнт і сервер можуть мати різні відображення шляхів до файлових систем. Це означало б, що або клієнт повинен розбити ім'я шляху в точках приєднання файлової системи, або сервер повинен знати про точки приєднання файлової системи клієнта. У реалізаціях протоколу NFS версії 3 саме клієнт створює ієрархічний простір імен файлів за допомогою монтувань для створення ієрархії. Утиліти підтримки, такі як Automounter, надають спосіб керування спільним узгодженим образом простору імен файлів, водночас керуючи процесом монтування клієнта.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Клієнти можуть виконувати кешування різними способами. Загальна практика використання протоколу NFS версії 2 полягала в реалізації механізму узгодженості кешу клієнт-сервер на основі часу. Очікується, що реалізації протоколу NFS версії 3 використовуватимуть подібний механізм. Протокол NFS версії 3 має деяку явну підтримку у формі додаткової інформації про атрибути для усунення явних перевірок атрибутів. Однак кешування не обовʼязкове, а також протокол не визначає жодної політики кешування. Ні протокол NFS версії 2, ні протокол NFS версії 3 не забезпечують засоби підтримки суворої узгодженості клієнт-сервер (і, як наслідок, узгодженості між клієнтськими кешами).</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    
    
    <p class="P3" id="section_1.7">1.7 Зміни порівняно з протоколом NFS версії 2</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Процедури ROOT і WRITECACHE видалено. </p>
    <p class="Pr_20_Text">   Процедура MKNOD була визначена для створення спеціальних файлів, усуваючи перевантаження CREATE.</p>
    <p class="Pr_20_Text">   Кешування на клієнті не визначено і не продиктовано протоколом NFS версії 3, але додаткову інформацію та підказки було додано до протоколу, щоб клієнти, які використовують кешування, могли ефективніше керувати своїми кешами. Процедури, які впливають на атрибути файлу або директорії, тепер можуть повертати нові атрибути після завершення операції, щоб оптимізувати подальший GETATTR, який використовується для перевірки кешів атрибутів. Крім того, операції, які змінюють директорію, у якій знаходиться цільовий об’єкт, повертають старі та нові атрибути директорії, щоб дозволити клієнтам реалізувати більш інтелектуальні процедури анулювання кешу. Процедура ACCESS забезпечує перевірку прав доступу на сервері, процедура FSSTAT повертає динамічну інформацію про файлову систему, процедура FSINFO повертає статичну інформацію про файлову систему та сервер, процедура READDIRPLUS повертає файлові дескриптори і атрибути на додаток до записів директорії, і процедура PATHCONF повертає інформацію POSIX pathconf pro-file.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Нижче наведено список важливих змін між протоколом NFS версії 2 і протоколом NFS версії 3.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Розмір дескриптора файлу</p>
    <p class="Pr_20_Text">      Дескриптор файлу було збільшено з фіксованого масиву 32 байти до масиву змінної довжини максимум 64 байти. Це стосується деяких відомих вимог щодо дещо більшого розміру файлового дескриптора. Ідентифікатор файлу було перетворено з фіксованої довжини на змінну, щоб зменшити вимоги до локальної пам’яті та пропускної здатності мережі для систем, які не використовують повні 64 байти.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Максимальний розмір даних</p>
    <p class="Pr_20_Text">      Максимальний розмір передачі даних, що використовується в процедурах READ і WRITE, тепер встановлюється значеннями в структурі повернення FSINFO. Крім того, FSINFO повертає бажані розміри переказу. Протокол не накладає жодних штучних обмежень на максимальні розміри передачі. Імена файлів і шляхи тепер вказуються як рядки змінної довжини. Фактичні обмеження довжини визначаються реалізаціями клієнта та сервера відповідно. Протокол не встановлює жодних штучних обмежень щодо довжини. Помилка NFS3ERR_NAMETOOLONG надається, щоб дозволити серверу повертати клієнту вказівку про те, що він отримав шлях, який був занадто довгим для обробки.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Повернення помилки</p>
    <p class="Pr_20_Text">      У деяких випадках помилка повертає дані (наприклад, атрибути). Тепер nfsstat3 визначає повний набір помилок, які може повертати сервер. Інші значення не допускаються.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Тип файлу</p>
    <p class="Pr_20_Text">      Тип файлу тепер включає NF3CHR і NF3BLK для спеціальних файлів. Атрибути для цих типів включають підполя для основних і другорядних номерів пристроїв UNIX. NF3SOCK і NF3FIFO тепер визначені для сокетів і файлів FIFO у файловій системі.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Атрибути файлів</p>
    <p class="Pr_20_Text">      Поле blocksize (розмір у байтах блоку у файлі) видалено. Поле режиму більше не містить інформації про тип файлу. Поля size та fileid було розширено з чотирьохбайтових цілих чисел до восьмибайтових цілих чисел без знаку. Основна та другорядна інформація про пристрій тепер представлена в окремій структурі. Ім’я поля блоків було змінено на used і тепер містить загальну кількість байтів, які використовує файл. Це також восьмибайтове ціле число без знаку.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Встановлення атрибутів файла</p>
    <p class="Pr_20_Text">      У протоколі NFS версії 2 встановлювані атрибути були представлені підмножиною структури атрибутів файлу; клієнт вказував ті атрибути, які не підлягали зміні, встановивши для відповідного поля значення -1, перевантаживши деякі непідписані поля. У структурі встановлених атрибутів файлів тепер використовується дискриміноване об’єднання (discriminated union) для кожного поля, щоб визначити, чи встановлювати це поле, або як встановити це поле. У полях atime та mtime можна встановити поточний час сервера або час, наданий клієнтом.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   LOOKUP</p>
    <p class="Pr_20_Text">      Структура повернення LOOKUP тепер включає атрибути для директорії, у якому шукали.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   ACCESS</p>
    <p class="Pr_20_Text">      Додано процедуру ACCESS, щоб дозволити явну перевірку дозволів на мережеве з’єднання. Це вирішує відомі проблеми з функцією cпівставлення ідентифікатора суперкористувача в багатьох реалізаціях сервера (де через співставлення користувача root під час читання з файлу або запису в нього можуть виникати неочікувані помилки відмови в дозволі). Це також усуває припущення, зроблене в протоколі NFS версії 2, що доступ до файлів базується виключно на бітах режиму стилю UNIX.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   READ</p>
    <p class="Pr_20_Text">      Структура відповіді включає логічне поле, яке має значення TRUE, якщо під час READ було виявлено кінець файлу. Це дозволяє клієнту правильно визначити кінець файлу.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   WRITE</p>
    <p class="Pr_20_Text">      Поля beginoffset і totalcount видалено з аргументів WRITE. Відповідь тепер містить кількість даних, щоб сервер за необхідності міг записати менше даних ніж запитуваний обсяг даних. До аргументів було додано індикатор, який повідомляє серверу про рівень синхронізації кешу, який вимагається клієнтом.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   CREATE</p>
    <p class="Pr_20_Text">      Для ексклюзивного створення звичайних файлів додано ексклюзивний прапор і верифікатор створення.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   МКNOD</p>
    <p class="Pr_20_Text">      Ця процедура була додана для підтримки створення спеціальних файлів. Це дозволяє уникнути перевантаження полів CREATE, як це було зроблено в деяких реалізаціях протоколу NFS версії 2.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   READDIR</p>
    <p class="Pr_20_Text">      Аргументи READDIR тепер містять верифікатор, який дозволяє серверу перевірити cookie. Cookie тепер є 64-розрядним цілим числом без знаку замість 4-байтового масиву, який використовувався в протоколі NFS версії 2. Це допоможе зменшити проблеми сумісності.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   READDIRPLUS</p>
    <p class="Pr_20_Text">      Ця процедура була додана для повернення файлових дескрипторів і атрибутів у розширеному списку каталогів.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   FSINFO</p>
    <p class="Pr_20_Text">      FSINFO було додано для надання незмінної нформації про файлову систему. Відповідь містить бажаний і максимальний розмір передачі при читанні, бажаний і максимальний розмір передачі при записі, а також прапорці, які вказують, чи підтримуються посилання чи символічні посилання. Також повертається бажаний розмір передачі для відповідей процедури READDIR, деталізація часу сервера та можливість встановлення часу в запиті SETATTR.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   FSSTAT</p>
    <p class="Pr_20_Text">      FSSTAT було додано для надання змінювальної інформації про файлову систему для використання утилітами, такими як команда Unix систем `df`. Відповідь містить загальний розмір і вільний простір у файловій системі, вказаний у байтах, загальну кількість файлів і кількість вільних слотів для файлів у файловій системі, а також оцінку часу між змінами файлової системи (для використання в алгоритмах перевірки узгодженості кешу).</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   COMMIT</p>
    <p class="Pr_20_Text">      Процедура COMMIT забезпечує механізм синхронізації для використання асинхронного WRITE</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <hr>
    <p class="Pr_20_Text"> </p>
    
    
    
    <p class="P2" id="section_2">2. Інформація RPC </p>
    <p class="Pr_20_Text"> </p>
    
    <p class="P3" id="section_2.1">2.1 Автентифікація</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">  Служба NFS використовує AUTH_NONE у процедурі NULL. AUTH_UNIX, AUTH_DES або AUTH_KERB використовуються для всіх інших процедур. Інші типи автентифікації можуть підтримуватися в майбутньому.</p>
    <p class="Pr_20_Text"> </p>
    
    <p class="P3" id="section_2.2">2.2 Константи</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">  Це константи RPC, які необхідні для виклику служби NFS версії 3. Вони подані в десятковому вигляді.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">       PROGRAM 100003</p>
    <p class="Pr_20_Text">       VERSION 3</p>
    <p class="Pr_20_Text"> </p>
    
    <p class="P3" id="section_2.3">2.3 Транспортна адреса</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Протокол NFS зазвичай підтримується протоколами TCP і UDP. Він використовує порт 2049, такий же, як і протокол NFS версії 2.</p>
    <p class="Pr_20_Text"> </p>
    
    <p class="P3" id="section_2.4">2.4 Розміри</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Це розміри в десяткових байтах різних структур XDR, які використовуються в протоколі NFS версії 3:</p>
    <p class="Pr_20_Text">      NFS3_FHSIZE 64</p>
    <p class="Pr_20_Text">           Максимальний розмір непрозорого файлового дескриптора в байтах.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      NFS3_COOKIEVERFSIZE 8</p>
    <p class="Pr_20_Text">           Розмір у
        байтах непрозорого засобу перевірки файлів cookie, який передають READDIR і READDIRPLUS.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      NFS3_CREATEVERFSIZE 8</p>
    <p class="Pr_20_Text">           Розмір у байтах непрозорого верифікатора, який використовується для ексклюзивного CREATE.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      NFS3_WRITEVERFSIZE 8</p>
    <p class="Pr_20_Text">           Розмір у байтах непрозорого верифікатора, який використовується для асинхронного запису.</p>
    <p class="Pr_20_Text">  </p>
    <p class="Pr_20_Text"> </p>
    
    <p class="P3" id="section_2.5">2.5 Основні типи даних</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Наступні визначення XDR є основними визначеннями, які використовуються в інших структурах.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     uint64</p>
    <p class="Pr_20_Text">         typedef unsigned hyper uint64;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     int64</p>
    <p class="Pr_20_Text">         typedef hyper int64;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     uint32</p>
    <p class="Pr_20_Text">         typedef unsigned long uint32;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     int32</p>
    <p class="Pr_20_Text">         typedef long int32;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     filename3</p>
    <p class="Pr_20_Text">         typedef string filename3&lt;&gt;;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     nfspath3</p>
    <p class="Pr_20_Text">         typedef string nfspath3&lt;&gt;;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     fileid3</p>
    <p class="Pr_20_Text">         typedef uint64 fileid3;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     cookie3</p>
    <p class="Pr_20_Text">         typedef uint64 cookie3;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     cookieverf3</p>
    <p class="Pr_20_Text">         typedef opaque cookieverf3[NFS3_COOKIEVERFSIZE];</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     createverf3</p>
    <p class="Pr_20_Text">         typedef opaque createverf3[NFS3_CREATEVERFSIZE];</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     writeverf3</p>
    <p class="Pr_20_Text">         typedef opaque writeverf3[NFS3_WRITEVERFSIZE];</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     uid3</p>
    <p class="Pr_20_Text">         typedef uint32 uid3;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     gid3</p>
    <p class="Pr_20_Text">         typedef uint32 gid3;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     size3</p>
    <p class="Pr_20_Text">         typedef uint64 size3;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     offset3</p>
    <p class="Pr_20_Text">         typedef uint64 offset3;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     mode3</p>
    <p class="Pr_20_Text">         typedef uint32 mode3;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     count3</p>
    <p class="Pr_20_Text">         typedef uint32 count3;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     nfsstat3</p>
    <p class="Pr_20_Text">      enum nfsstat3 {</p>
    <p class="Pr_20_Text">         NFS3_OK             = 0,</p>
    <p class="Pr_20_Text">         NFS3ERR_PERM        = 1,</p>
    <p class="Pr_20_Text">         NFS3ERR_NOENT       = 2,</p>
    <p class="Pr_20_Text">         NFS3ERR_IO          = 5,</p>
    <p class="Pr_20_Text">         NFS3ERR_NXIO        = 6,</p>
    <p class="Pr_20_Text">         NFS3ERR_ACCES       = 13,</p>
    <p class="Pr_20_Text">         NFS3ERR_EXIST       = 17,</p>
    <p class="Pr_20_Text">         NFS3ERR_XDEV        = 18,</p>
    <p class="Pr_20_Text">         NFS3ERR_NODEV       = 19,</p>
    <p class="Pr_20_Text">         NFS3ERR_NOTDIR      = 20,</p>
    <p class="Pr_20_Text">         NFS3ERR_ISDIR       = 21,</p>
    <p class="Pr_20_Text">         NFS3ERR_INVAL       = 22,</p>
    <p class="Pr_20_Text">         NFS3ERR_FBIG        = 27,</p>
    <p class="Pr_20_Text">         NFS3ERR_NOSPC       = 28,</p>
    <p class="Pr_20_Text">         NFS3ERR_ROFS        = 30,</p>
    <p class="Pr_20_Text">         NFS3ERR_MLINK       = 31,</p>
    <p class="Pr_20_Text">         NFS3ERR_NAMETOOLONG = 63,</p>
    <p class="Pr_20_Text">         NFS3ERR_NOTEMPTY    = 66,</p>
    <p class="Pr_20_Text">         NFS3ERR_DQUOT       = 69,</p>
    <p class="Pr_20_Text">         NFS3ERR_STALE       = 70,</p>
    <p class="Pr_20_Text">         NFS3ERR_REMOTE      = 71,</p>
    <p class="Pr_20_Text">         NFS3ERR_BADHANDLE   = 10001,</p>
    <p class="Pr_20_Text">         NFS3ERR_NOT_SYNC    = 10002,</p>
    <p class="Pr_20_Text">         NFS3ERR_BAD_COOKIE  = 10003,</p>
    <p class="Pr_20_Text">         NFS3ERR_NOTSUPP     = 10004,</p>
    <p class="Pr_20_Text">         NFS3ERR_TOOSMALL    = 10005,</p>
    <p class="Pr_20_Text">         NFS3ERR_SERVERFAULT = 10006,</p>
    <p class="Pr_20_Text">         NFS3ERR_BADTYPE     = 10007,</p>
    <p class="Pr_20_Text">         NFS3ERR_JUKEBOX     = 10008</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Тип nfsstat3 повертається з результатами кожної процедури, за винятком процедури NULL. Значення NFS3_OK вказує на успішне завершення виклику. Будь-яке інше значення вказує на те, що під час виклику сталася якась помилка, яка визначається кодом помилки. Зауважте, що необхідно дотримуватися точного цифрового кодування. Жодні інші значення не можуть повертатися сервером. Очікується, що сервери докладуть максимум зусиль, щоб співставити умови помилки з набором визначених кодів помилок. Крім того, ця специфікація не визначає пріоритети помилок. Пріоритети помилок визначають значення помилки, яке має бути повернуто, якщо в даній ситуації застосовується більше ніж одна помилка. Пріоритет помилок визначатиметься індивідуальною реалізацією сервера. Якщо клієнту потрібні певні пріоритети помилок, він повинен самостійно перевірити наявність конкретних помилок.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    
    <p class="P3" id="section_2.6">2.6 Визначені номери помилок</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Нижче наведено опис кожної визначеної помилки:</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   NFS3_OK</p>
    <p class="Pr_20_Text">        Вказує на успішне завершення виклику.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   NFS3ERR_PERM</p>
    <p class="Pr_20_Text">        Не власник. Операцію було заборонено, оскільки викликаючий або не є привілейованим користувачем (root), або не є власником цільової операції.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_NOENT</p>
    <p class="Pr_20_Text">        Немає такого файлу чи каталогу. Вказана назва файлу або каталогу не існує.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_IO</p>
    <p class="Pr_20_Text">        I/O error. Під час обробки запитуваної операції сталася серйозна помилка (наприклад, помилка диска).</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_NXIO</p>
    <p class="Pr_20_Text">        I/O error. Немає такого пристрою чи адреси.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_ACCES</p>
    <p class="Pr_20_Text">        У доступі відмовлено. Викликаючий не має належного дозволу на виконання потрібної операції. Порівняйте це з NFS3ERR_PERM, який обмежується помилками дозволу власника або привілейованого користувача.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_EXIST</p>
    <p class="Pr_20_Text">        Файл існує. Зазначений файл вже існує.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_XDEV</p>
    <p class="Pr_20_Text">        Спроба зробити жорстке посилання між пристроями.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_NODEV</p>
    <p class="Pr_20_Text">        Немає такого пристрою.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_NOTDIR</p>
    <p class="Pr_20_Text">        Не є каталогом. Викликаючий вказав не каталог під час операції з каталогом.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_ISDIR</p>
    <p class="Pr_20_Text">        Є каталогом. Викликаючий вказав каталог у операції, яка не є каталогом.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_INVAL</p>
    <p class="Pr_20_Text">        Недійсний або непідтримуваний аргумент для операції. Два приклади: спроба READLINK на об’єкті, який не є символічним посиланням, або спроба SETATTR поля часу на сервері, який не підтримує цю операцію.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_FBIG</p>
    <p class="Pr_20_Text">        Файл завеликий. Ця операція призвела б до того, що розмір файлу перевищив би обмеження сервера.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_NOSPC</p>
    <p class="Pr_20_Text">        На пристрої не залишилося місця. Операція призвела б до перевищення ліміту файлової системи сервера.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_ROFS</p>
    <p class="Pr_20_Text">        Файлова система лише для читання. Здійснено спробу модифікації файлової системи, доступної лише для читання.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_MLINK</p>
    <p class="Pr_20_Text">        Забагато жорстких посилань.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_NAMETOOLONG</p>
    <p class="Pr_20_Text">        Назва файлу в операції була задовгою.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_NOTEMPTY</p>
    <p class="Pr_20_Text">        Було зроблено спробу видалити каталог, який не був порожнім.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_DQUOT</p>
    <p class="Pr_20_Text">        Перевищено жорсткий ліміт ресурсу (квоту). Перевищено ліміт ресурсів користувача на сервері.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_STALE</p>
    <p class="Pr_20_Text">        Недійсний файловий дескриптор. Дескриптор файлу, указаний в аргументах, недійсний. Файл, на який посилається цей дескриптор файлу або більше не існує, або доступ до нього відкликаний.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_REMOTE</p>
    <p class="Pr_20_Text">        Забагато рівнів віддаленого шляху. Дескриптор файлу, поданий в аргументах, посилався на файл у нелокальній файловій системі на сервері.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_BADHANDLE</p>
    <p class="Pr_20_Text">        Некоректний файловий дескриптор NFS. Дескриптор файлу не пройшов перевірку внутрішньої узгодженості.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_NOT_SYNC</p>
    <p class="Pr_20_Text">        Виявлено невідповідність синхронізації оновлень під час операції SETATTR.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_BAD_COOKIE</p>
    <p class="Pr_20_Text">        Файл cookie READDIR або READDIRPLUS застарів.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_NOTSUPP</p>
    <p class="Pr_20_Text">        Операція не підтримується.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_TOOSMALL</p>
    <p class="Pr_20_Text">        Замалий буфер або запит.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_SERVERFAULT</p>
    <p class="Pr_20_Text">        На сервері сталася помилка, яка не відповідає жодному з допустимих значень помилки протоколу NFS версії 3. Клієнт мусить перевести це у відповідну помилку. Клієнти UNIX можуть обрати транслювати це у EIO.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_BADTYPE</p>
    <p class="Pr_20_Text">        Було зроблено спробу створити об’єкт типу, який не підтримується сервером.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    NFS3ERR_JUKEBOX</p>
    <p class="Pr_20_Text">        Сервер ініціював запит, але не зміг виконати його вчасно. Клієнт повинен зачекати, а потім спробувати запит із новим ідентифікатором транзакції RPC. Наприклад, цю помилку має повертати сервер, який підтримує ієрархічне зберігання та отримує запит на обробку файлу, який було перенесено. У цьому випадку сервер повинен розпочати процес імміграції та відповісти клієнту цією помилкою.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   ftype3</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      enum ftype3 {</p>
    <p class="Pr_20_Text">         NF3REG    = 1,</p>
    <p class="Pr_20_Text">         NF3DIR    = 2,</p>
    <p class="Pr_20_Text">         NF3BLK    = 3,</p>
    <p class="Pr_20_Text">         NF3CHR    = 4,</p>
    <p class="Pr_20_Text">         NF3LNK    = 5,</p>
    <p class="Pr_20_Text">         NF3SOCK   = 6,</p>
    <p class="Pr_20_Text">         NF3FIFO   = 7</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Перелік ftype3 визначає тип файлу. Тип NF3REG — це звичайний файл, NF3DIR — це каталог, NF3BLK — це блоковий файл спеціального пристрою, NF3CHR — це символьний файл спеціального пристрою, NF3LNK — це символьне посилання, NF3SOCK — це сокет, а NF3FIFO — це іменований канал. Зауважте, що потрібно дотримуватися точного кодування enum.     </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   specdata3</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">       struct specdata3 {</p>
    <p class="Pr_20_Text">            uint32 specdata1;</p>
    <p class="Pr_20_Text">            uint32 specdata2;</p>
    <p class="Pr_20_Text">       };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Інтерпретація цих двох елементів залежить від типу об'єкта файлової системи. Для спеціального блокового (NF3BLK) або спеціального символьного (NF3CHR) файлу specdata1 і specdata2 є основним і другорядним номерами пристроїв відповідно. (Це, очевидно, специфічна інтерпретація для UNIX.) Для всіх інших типів файлів ці два елементи мають бути встановлені на 0 або значення повинні бути узгоджені між клієнтом і сервером. Якщо клієнт і сервер не згодні щодо значень, клієнт повинен обробляти ці поля так, ніби вони мають значення 0. Це поле даних повертається як частина структури fattr3 і тому доступне з усіх атрибутів, що повертають відповіді.  Оскільки в інших випадках ці поля не використовуються для об’єктів, які не є пристроями, інформація поза діапазоном може передаватися від сервера до клієнта. Однак знову ж таки, як сервер, так і клієнт повинні узгодити передані значення.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     nfs_fh3</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      struct nfs_fh3 {</p>
    <p class="Pr_20_Text">         opaque       data&lt;NFS3_FHSIZE&gt;;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Nfs_fh3 — це непрозорий об’єкт змінної довжини, який повертається сервером під час виконання операцій LOOKUP, CREATE, SYMLINK, MKNOD, LINK або READDIRPLUS і використовується клієнтом під час наступних операцій для посилання на файл. Файловий дескриптор містить усю інформацію, необхідну серверу для розрізнення окремого файлу. Для клієнта  файловий дескриптор непрозорий. Клієнт зберігає файлові дескриптори для використання в наступному запиті та може порівнювати два файлих дескриптора з одного сервера на предмет еквівалентності, виконуючи побайтове порівняння, але не може інакше інтерпретувати вміст файлових дескрипторів. Якщо два файлових дескриптори з одного сервера однакові, вони мають посилатися на той самий файл, але якщо вони не однакові, неможливо зробити жодних висновків. Сервери повинні намагатися підтримувати однозначну відповідність між дескрипторами файлів і файлами, але це не обов’язково. Клієнти повинні використовувати порівняння файлових дескрипторів лише для покращення продуктивності, а не для правильної поведінки.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Сервери можуть у будь-який час скасувати доступ, наданий файловим дескриптором. Якщо дескриптор файлу, переданий у виклику, посилається на об’єкт файлової системи, який більше не існує на сервері, або доступ до цього файлового дескриптора скасовано, має бути повернуто помилку NFS3ERR_STALE.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   nfstime3</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      struct nfstime3 {</p>
    <p class="Pr_20_Text">         uint32   seconds;</p>
    <p class="Pr_20_Text">         uint32   nseconds;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Структура nfstime3 надає кількість секунд і наносекунд, які пройшли з опівночі 1 січня 1970 року за Гринвічем. Вона використовується для передачі інформації про час і дату. Час, пов’язаний з файлами, є часом сервера, за винятком операції SETATTR, де клієнт може явно встановити час файлу. Під час обробки значень часу сервер переводить його на місцевий час та назад, зберігаючи максимальну точність. Якщо точність позначок часу, збережених для файлу, менша, ніж визначена протоколом NFS версії 3, точність може бути втрачена. Рекомендується додатковий протокол обслуговування часу, щоб зменшити розбіжності часу клієнта та сервера</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   fattr3</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      struct fattr3 {</p>
    <p class="Pr_20_Text">         ftype3     type;</p>
    <p class="Pr_20_Text">         mode3      mode;</p>
    <p class="Pr_20_Text">         uint32     nlink;</p>
    <p class="Pr_20_Text">         uid3       uid;</p>
    <p class="Pr_20_Text">         gid3       gid;</p>
    <p class="Pr_20_Text">         size3      size;</p>
    <p class="Pr_20_Text">         size3      used;</p>
    <p class="Pr_20_Text">         specdata3  rdev;</p>
    <p class="Pr_20_Text">         uint64     fsid;</p>
    <p class="Pr_20_Text">         fileid3    fileid;</p>
    <p class="Pr_20_Text">         nfstime3   atime;</p>
    <p class="Pr_20_Text">         nfstime3   mtime;</p>
    <p class="Pr_20_Text">         nfstime3   ctime;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">  Ця структура визначає атрибути об'єкта файлової системи. Вона повертається більшістю операцій над об’єктом; у випадку операцій, які впливають на два об’єкти (наприклад, MKDIR, яка змінює атрибути цільового каталогу та визначає нові атрибути для новоствореного каталогу), можуть бути повернуті атрибути для обох. У деяких випадках атрибути повертаються у структурі wcc_data, яка визначена нижче; в інших випадках
        атрибути повертаються окремо. Основні зміни порівняно з протоколом NFS версії 2 полягають у тому, що багато полів було розширено, а головна/другорядна інформація про пристрій тепер представлена в окремій структурі, а не упакована в один вираз.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">  Структура fattr3 містить основні атрибути файлу. Усі сервери повинні підтримувати цей набір атрибутів, навіть якщо їм потрібно імітувати деякі поля. Type — це тип файлу. Mode — це біти режиму захисту. Nlink — це кількість жорстких посилань на файл, тобто кількість різних імен для одного файлу. Uid — це ідентифікатор користувача, який є власником файла. Gid — ID групи файла. Size — це розмір файлу в байтах. Used — це кількість байтів дискового простору, яку фактично використовує файл (яка може бути меншою за розмір, оскільки у файлі можуть бути пропуски, або вона може бути більшою через фрагментацію). Rdev описує файл пристрою, якщо тип файлу NF3CHR або NF3BLK - дивіться specdata3. Fsid — це ідентифікатор файлової системи для файлової системи. Fileid — це номер, який унікально ідентифікує файл у його файловій системі (в UNIX це буде inumber). Atime – це час останнього доступу до даних файлу. Mtime – це час останньої зміни даних файлу. Ctime – це час останньої зміни атрибутів файлу. Запис у файл змінює ctime на додаток до mtime.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Біти режиму визначаються наступним чином:</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">       0x00800 Встановити user ID під час виконання.</p>
    <p class="Pr_20_Text">       0x00400 Встановити group ID під час виконання.</p>
    <p class="Pr_20_Text">       0x00200 Зберегти замінений текст (не визначено в POSIX).</p>
    <p class="Pr_20_Text">       0x00100 Дозвіл на читання для власника.</p>
    <p class="Pr_20_Text">       0x00080 Дозвіл на запис для власника.</p>
    <p class="Pr_20_Text">       0x00040 Дозвіл на виконання для власника файлу. Або дозвіл на пошук (search) для власника в каталозі.</p>
    <p class="Pr_20_Text">       0x00020 Дозвіл на читання для групи.</p>
    <p class="Pr_20_Text">       0x00010 Дозвіл на запис для групи.</p>
    <p class="Pr_20_Text">       0x00008 Дозвіл на виконання для групи на файл. Або дозвіл на пошук (search) для групи в каталозі.</p>
    <p class="Pr_20_Text">       0x00004 Дозвіл на читання для інших.</p>
    <p class="Pr_20_Text">       0x00002 Дозвіл на запис для інших.</p>
    <p class="Pr_20_Text">       0x00001 Дозвіл на виконання для інших на файл. Або дозвіл на пошук (search) для інших у каталозі.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   post_op_attr</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      union post_op_attr switch (bool attributes_follow) {</p>
    <p class="Pr_20_Text">        case TRUE:</p>
    <p class="Pr_20_Text">           fattr3   attributes;</p>
    <p class="Pr_20_Text">        case FALSE:</p>
    <p class="Pr_20_Text">           void;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Ця структура використовується для повернення атрибутів у тих операціях, які безпосередньо не пов’язані з маніпулюванням атрибутами. Одним із принципів цієї версії протоколу NFS є повернення реального значення від зазначеної операції, а не помилки від випадкової операції. Структура post_op_attr була розроблена, щоб дозволити серверу відновлюватися після помилок, які виникли під час отримання атрибутів.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Здається, що це робить повернення атрибутів необов’язковим. Проте розробникам серверів настійно рекомендується докладати максимум зусиль для повернення атрибутів, коли це можливо, навіть якщо повертається помилка.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">     wcc_attr</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      struct wcc_attr {</p>
    <p class="Pr_20_Text">         size3       size;</p>
    <p class="Pr_20_Text">         nfstime3    mtime;</p>
    <p class="Pr_20_Text">         nfstime3    ctime;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Це підмножина атрибутів pre-operation, необхідних для кращої підтримки семантики слабкої узгодженості кешу. Size — це розмір файлу в байтах об’єкта до операції. Mtime — час останньої модифікації об'єкта перед операцією. Ctime - це час останньої зміни атрибутів об'єкта перед операцією. Див. обговорення в wcc_attr.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Використання mtime клієнтами для виявлення змін в об’єктах файлової системи, що знаходяться на сервері, залежить від деталізації бази часу на сервері.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   pre_op_attr</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      union pre_op_attr switch (bool attributes_follow) {</p>
    <p class="Pr_20_Text">      case TRUE:</p>
    <p class="Pr_20_Text">           wcc_attr  attributes;</p>
    <p class="Pr_20_Text">      case FALSE:</p>
    <p class="Pr_20_Text">           void;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   wcc_data</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      struct wcc_data {</p>
    <p class="Pr_20_Text">         pre_op_attr    before;</p>
    <p class="Pr_20_Text">         post_op_attr   after;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Коли клієнт виконує операцію, яка змінює стан файлу або каталогу на сервері, він не може відразу за атрибутами після операції визначити, чи була щойно виконана операція єдиною операцією над об’єктом з моменту останнього отримання клієнтом атрибутів цього об'єкта. Це важливо, оскільки якщо проміжна операція змінила об’єкт, клієнту потрібно буде визнати недійсними будь-які кешовані дані для об’єкта (за винятком даних, які він щойно записав).</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Щоб впоратися з цим, вводиться поняття слабкої узгодженості даних кешу (weak cache consistency data) або wcc_data. Структура wcc_data складається з певних ключових полів з атрибутами об’єкта до операції разом з атрибутами об’єкта після операції. Ця інформація дозволяє клієнту керувати кеш-пам’яттю точніше, ніж у реалізаціях протоколу NFS версії 2. Термін слабка узгодженість кешу підкреслює той факт, що цей механізм не забезпечує суворої узгодженості між сервером і клієнтом, яку забезпечує протокол узгодженості кешу.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Щоб підтримувати модель слабкої узгодженості кешу, сервер повинен мати можливість атомарно отримати атрибути об’єкта перед операцією, виконати заплановану операцію зміни, а потім отримати атрибути після операції. Якщо існує вікно для модифікації об’єкта між операцією та будь-якою з операцій отримання атрибутів, тоді клієнт не зможе визначити, чи був він єдиною сутністю, яка модифікувала об’єкт. Деяка інформація буде втрачена, що послабить слабкі гарантії узгодженості кешу.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   post_op_fh3</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      union post_op_fh3 switch (bool handle_follows) {</p>
    <p class="Pr_20_Text">      case TRUE:</p>
    <p class="Pr_20_Text">           nfs_fh3  handle;</p>
    <p class="Pr_20_Text">      case FALSE:</p>
    <p class="Pr_20_Text">           void;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Одним із принципів цієї версії протоколу NFS є повернення реального значення від зазначеної операції, а не помилки від випадкової операції. Структура post_op_fh3 була розроблена, щоб дозволити серверу відновлюватися після помилок, які виникли під час створення дескриптора файла.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Це структура, яка використовується для повернення дескрипторів файлу після запитів CREATE, MKDIR, SYMLINK, MKNOD і READDIRPLUS. У кожному разі клієнт може отримати дескриптор файлу, видавши запит LOOKUP після успішного повернення з однієї з перелічених операцій. Повернення дескриптора файлу є оптимізацією, щоб клієнт не був змушений негайно надсилати запит LOOKUP, щоб отримати дескриптор файлу.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   sattr3</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      enum time_how {</p>
    <p class="Pr_20_Text">         DONT_CHANGE        = 0,</p>
    <p class="Pr_20_Text">         SET_TO_SERVER_TIME = 1,</p>
    <p class="Pr_20_Text">         SET_TO_CLIENT_TIME = 2</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      union set_mode3 switch (bool set_it) {</p>
    <p class="Pr_20_Text">      case TRUE:</p>
    <p class="Pr_20_Text">         mode3    mode;</p>
    <p class="Pr_20_Text">      default:</p>
    <p class="Pr_20_Text">         void;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      union set_uid3 switch (bool set_it) {</p>
    <p class="Pr_20_Text">      case TRUE:</p>
    <p class="Pr_20_Text">         uid3     uid;</p>
    <p class="Pr_20_Text">      default:</p>
    <p class="Pr_20_Text">         void;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      union set_gid3 switch (bool set_it) {</p>
    <p class="Pr_20_Text">      case TRUE:</p>
    <p class="Pr_20_Text">         gid3     gid;</p>
    <p class="Pr_20_Text">      default:</p>
    <p class="Pr_20_Text">         void;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      union set_size3 switch (bool set_it) {</p>
    <p class="Pr_20_Text">      case TRUE:</p>
    <p class="Pr_20_Text">         size3    size;</p>
    <p class="Pr_20_Text">      default:</p>
    <p class="Pr_20_Text">         void;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      union set_atime switch (time_how set_it) {</p>
    <p class="Pr_20_Text">      case SET_TO_CLIENT_TIME:</p>
    <p class="Pr_20_Text">         nfstime3  atime;</p>
    <p class="Pr_20_Text">      default:</p>
    <p class="Pr_20_Text">         void;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      union set_mtime switch (time_how set_it) {</p>
    <p class="Pr_20_Text">      case SET_TO_CLIENT_TIME:</p>
    <p class="Pr_20_Text">         nfstime3  mtime;</p>
    <p class="Pr_20_Text">      default:</p>
    <p class="Pr_20_Text">         void;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      struct sattr3 {</p>
    <p class="Pr_20_Text">         set_mode3   mode;</p>
    <p class="Pr_20_Text">         set_uid3    uid;</p>
    <p class="Pr_20_Text">         set_gid3    gid;</p>
    <p class="Pr_20_Text">         set_size3   size;</p>
    <p class="Pr_20_Text">         set_atime   atime;</p>
    <p class="Pr_20_Text">         set_mtime   mtime;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Структура sattr3 містить атрибути файлів, які можна встановити з клієнта. Ці поля збігаються з полями з аналогічними назвами в структурі fattr3. У протоколі NFS версії 3 встановлювані атрибути описуються структурою, що містить набір об'єднань, які відрізняються. Кожне об'єднання вказує, чи потрібно оновлювати відповідний атрибут, і якщо так, то яким чином.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Використовуються дві форми discriminated unions. Під час встановлення режиму, uid, gid або розміру, об’єднання, яке відрізняється, перемикається на логічне значення set_it; якщо воно TRUE, тоді кодується значення відповідного типу.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Під час встановлення atime або mtime об’єднання перемикається на enumeration тип set_it. Якщо set_it має значення DONT_CHANGE, відповідний атрибут не змінюється. Якщо він має значення SET_TO_SERVER_TIME, відповідний атрибут встановлюється сервером на місцевий час; жодних даних клієнт не надає. Нарешті, якщо set_it має значення SET_TO_CLIENT_TIME, атрибут встановлюється на час, переданий клієнтом у структурі nfstime3. (Див. FSINFO у розділі, де розглядається питання деталізації часу).</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   diropargs3</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">      struct diropargs3 {</p>
    <p class="Pr_20_Text">         nfs_fh3     dir;</p>
    <p class="Pr_20_Text">         filename3   name;</p>
    <p class="Pr_20_Text">      };</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Структура diropargs3 використовується в операціях з каталогами. Дескриптор файлу, dir, визначає каталог, ім'я, у якому потрібно маніпулювати або отримати доступ до файлу. Див. додаткові коментарі в розділі «Обробка компонента імені файлу».</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
    <hr>
    <p class="Pr_20_Text"> </p>
    
    
    <p class="P2" id="section_3">3. Процедури сервера</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   У наступних розділах визначено процедури RPC, які надаються сервером протоколу NFS версії 3. Номер процедури RPC вказано у верхній частині сторінки з назвою. СИНОПСИС містить назву процедури, перелік імен аргументів, перелік імен результатів, а потім оголошення аргументів XDR і оголошення результатів. Інформація в SYNOPSIS указана мовою опису даних RPC, як визначено в [RFC1014]. Розділ DESCRIPTION розповідає, що має робити процедура, та як використовуються її аргументи та результати. У розділі ERROR перелічено помилки, які повертаються для певних типів помилок. Ці списки є посібником для більш поширених помилок, які можуть бути повернуті, і не є остаточним викладом усіх помилок, які можуть бути повернуті будь-якою конкретною процедурою.  Клієнтські реалізації повинні бути готові до роботи з неочікуваними помилками, що надходять від сервера. Поле IMPLEMENTATION надає інформацію про те, як очікується, що процедура працюватиме, та як її мають використовувати клієнти.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">         program NFS_PROGRAM {</p>
    <p class="Pr_20_Text">          version NFS_V3 {</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            void</p>
    <p class="Pr_20_Text">             NFSPROC3_NULL(void)                    = 0;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            GETATTR3res</p>
    <p class="Pr_20_Text">             NFSPROC3_GETATTR(GETATTR3args)         = 1;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            SETATTR3res</p>
    <p class="Pr_20_Text">             NFSPROC3_SETATTR(SETATTR3args)         = 2;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            LOOKUP3res</p>
    <p class="Pr_20_Text">             NFSPROC3_LOOKUP(LOOKUP3args)           = 3;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            ACCESS3res</p>
    <p class="Pr_20_Text">             NFSPROC3_ACCESS(ACCESS3args)           = 4;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            READLINK3res</p>
    <p class="Pr_20_Text">             NFSPROC3_READLINK(READLINK3args)       = 5;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            READ3res</p>
    <p class="Pr_20_Text">             NFSPROC3_READ(READ3args)               = 6;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            WRITE3res</p>
    <p class="Pr_20_Text">             NFSPROC3_WRITE(WRITE3args)             = 7;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            CREATE3res</p>
    <p class="Pr_20_Text">             NFSPROC3_CREATE(CREATE3args)           = 8;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            MKDIR3res</p>
    <p class="Pr_20_Text">             NFSPROC3_MKDIR(MKDIR3args)             = 9;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            SYMLINK3res</p>
    <p class="Pr_20_Text">             NFSPROC3_SYMLINK(SYMLINK3args)         = 10;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            MKNOD3res</p>
    <p class="Pr_20_Text">             NFSPROC3_MKNOD(MKNOD3args)             = 11;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            REMOVE3res</p>
    <p class="Pr_20_Text">             NFSPROC3_REMOVE(REMOVE3args)           = 12;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            RMDIR3res</p>
    <p class="Pr_20_Text">             NFSPROC3_RMDIR(RMDIR3args)             = 13;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            RENAME3res</p>
    <p class="Pr_20_Text">             NFSPROC3_RENAME(RENAME3args)           = 14;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            LINK3res</p>
    <p class="Pr_20_Text">             NFSPROC3_LINK(LINK3args)               = 15;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            READDIR3res</p>
    <p class="Pr_20_Text">             NFSPROC3_READDIR(READDIR3args)         = 16;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            READDIRPLUS3res</p>
    <p class="Pr_20_Text">             NFSPROC3_READDIRPLUS(READDIRPLUS3args) = 17;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            FSSTAT3res</p>
    <p class="Pr_20_Text">             NFSPROC3_FSSTAT(FSSTAT3args)           = 18;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            FSINFO3res</p>
    <p class="Pr_20_Text">             NFSPROC3_FSINFO(FSINFO3args)           = 19;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            PATHCONF3res</p>
    <p class="Pr_20_Text">             NFSPROC3_PATHCONF(PATHCONF3args)       = 20;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">            COMMIT3res</p>
    <p class="Pr_20_Text">             NFSPROC3_COMMIT(COMMIT3args)           = 21;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">         } = 3;</p>
    <p class="Pr_20_Text">      } = 100003;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Номери процедур поза діапазоном (невизначені) призводять до помилок RPC. Додаткову інформацію дивись у [RFC1057].</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
        
        
    <p class="P3" id="section_3.1">3.1 Загальні коментарі щодо атрибутів і узгоджених даних при відмовах</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Для тих процедур, які повертають структури post_op_attr або wcc_data у разі помилки, дискриміноване об’єднання може містити атрибути перед операцією об’єкта або батьківського каталогу об’єкта. Це залежить від виниклої помилки, а також може залежати від конкретної реалізації сервера. Розробникам настійно рекомендується повертати якомога більше даних атрибутів у разі помилки. Але розробники клієнта повинні знати, що їх реалізація повинна коректно обробляти екземпляр повернення варіанту, де не повертаються атрибути або дані узгодженості.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
        
    <p class="P3" id="section_3.2">3.2 Загальні коментарі щодо імен файлів</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Наступні коментарі стосуються всіх процедур протоколу NFS версії 3, у яких клієнт надає одне або кілька імен файлів у аргументах: LOOKUP, CREATE, MKDIR, SYMLINK, MKNOD, REMOVE, RMDIR, RENAME та LINK.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   1. Ім’я файлу не має бути порожнім (null) або порожнім рядком (null string). Сервер повинен повернути помилку NFS3ERR_ACCES, якщо він отримує таке ім’я файлу. На деяких клієнтах ім'я файлу, ``'' або порожня строка, вважається псевдонімом для поточного каталогу. Клієнти, яким потрібна ця функціональність, повинні реалізувати її самостійно і не залежати від підтримки такої семантики сервером.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   2. Ім'я файлу "." вважається псевдонімом для поточної директорії. Клієнти, яким потрібна ця функціональність, повинні реалізувати її самостійно і не залежати від підтримки такої семантики сервером. Однак сервер повинен мати можливість правильно обробляти таку назву файлу.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   3. Ім’я файлу «..» вважається псевдонімом для батьківської директорії поточної директорії, тобто директорії, яка містить поточну директорію. Якщо сервер підтримує директорії, він повинен бути готовий обробляти цю семантику, навіть якщо ці директорії не містять записи UNIX-style "." або ".." .</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   4. Якщо назва файлу довша за максимальну для файлової системи (див. PATHCONF, зокрема name_max), результат залежить від значення прапорця PATHCONF, no_trunc. Якщо no_trunc має значення FALSE, ім’я файлу буде мовчки скорочено до name_max байтів. Якщо no_trunc має значення TRUE і ім’я файлу перевищує максимальну довжину імені файлу файлової системи сервера, операція завершиться помилкою NFS3ERR_NAMETOOLONG.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   5. Загалом, будуть символи, які сервер не зможе обробити як частину імені файлу. Цей набір символів буде відрізнятися від сервера до сервера та від реалізації до реалізації. У більшості випадків саме сервер керуватиме виглядом файлової системи клієнта. Якщо сервер отримує назву файлу, що містить символи, які він не може обробити, має бути повернуто повідомлення про помилку NFS3ERR_EACCES. Клієнтські реалізації повинні бути готові обробити цей побічний ефект неоднорідності.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   Дивіться також коментарі в розділі «Обробка компонента імені файлу».</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
        
        
    <p class="P3" id="section_3.3.0">3.3.0 Procedure 0: NULL – нічого не робити</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">   СИНОПСИС</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">       void NFSPROC3_NULL(void) = 0;</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    ОПИС</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">       Процедура NULL не виконує жодної роботи. Вона зроблена для тестування відповіді сервера та хронометражу.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    РЕАЛІЗАЦІЯ</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">       Важливо, щоб ця процедура взагалі не виконувала роботу, щоб її можна було використовувати для вимірювання накладних витрат на обробку запита. Згідно з угодою, процедура NULL ніколи не повинна вимагати жодної автентифікації. Сервер може ігнорувати цю угоду в більш безпечній реалізації, коли відповідь на виклик процедури NULL підтверджує існування ресурсу для неавтентифікованого клієнта.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">    ПОМИЛКИ</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text">       Оскільки процедура NULL не приймає аргументів протоколу NFS версії 3 і не повертає відповіді протоколу NFS версії 3, то процедура NULL не може повернути помилку протоколу NFS версії 3. Однак можливо, що деякі серверні реалізації можуть повертати помилки RPC на основі вимог безпеки та автентифікації.</p>
    <p class="Pr_20_Text"> </p>
    <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.1">3.3.1 Procedure 1: GETATTR - Отримати атрибути файла</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      GETATTR3res NFSPROC3_GETATTR(GETATTR3args) = 1;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct GETATTR3args {</p>
        <p class="Pr_20_Text">         nfs_fh3  object;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct GETATTR3resok {</p>
        <p class="Pr_20_Text">         fattr3   obj_attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union GETATTR3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">         GETATTR3resok  resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">         void;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Процедура GETATTR отримує атрибути для зазначеного об'єкта файлової системи. Об’єкт ідентифікується дескриптором файлу, який повернув сервер як частину відповіді від процедури LOOKUP, CREATE, MKDIR, SYMLINK, MKNOD або READDIRPLUS (або від служби MOUNT, описаної в іншому місці). При вході аргументи в GETATTR3args такі:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       object</p>
        <p class="Pr_20_Text">          Дескриптор файлу об'єкта, атрибути якого потрібно отримати.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Після успішного повернення GETATTR3res.status має значення NFS3_OK, а GETATTR3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       obj_attributes</p>
        <p class="Pr_20_Text">          Атрибути об'єкта.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       В іншому випадку GETATTR3res.status містить помилку, і інші результати не повертаються.     </p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Атрибути об'єктів файлової системи є основною відмінністю між різними операційними системами. Сервери повинні докладати всіх зусиль для підтримки всіх атрибутів у структурі fattr3, щоб клієнти могли розраховувати на це як на спільну основу. Може знадобитися деяке співставлення для відповідності локальних атрибутів у структурі fattr3.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Сьогодні більшість клієнтських реалізацій протоколу NFS версії 3 реалізують обмежену в часі схему кешування атрибутів, щоб зменшити перевірку атрибутів через мережу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     ERRORS</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">        NFS3ERR_IO</p>
        <p class="Pr_20_Text">        NFS3ERR_STALE</p>
        <p class="Pr_20_Text">        NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">        NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Дивись також </p>
        <p class="Pr_20_Text">       ACCESS.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.2">3.3.2 Procedure 2: SETATTR - Установити атрибути файла</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      SETATTR3res NFSPROC3_SETATTR(SETATTR3args) = 2;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union sattrguard3 switch (bool check) {</p>
        <p class="Pr_20_Text">      case TRUE:</p>
        <p class="Pr_20_Text">         nfstime3  obj_ctime;</p>
        <p class="Pr_20_Text">      case FALSE:</p>
        <p class="Pr_20_Text">         void;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct SETATTR3args {</p>
        <p class="Pr_20_Text">         nfs_fh3      object;</p>
        <p class="Pr_20_Text">         sattr3       new_attributes;</p>
        <p class="Pr_20_Text">         sattrguard3  guard;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct SETATTR3resok {</p>
        <p class="Pr_20_Text">         wcc_data  obj_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct SETATTR3resfail {</p>
        <p class="Pr_20_Text">         wcc_data  obj_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union SETATTR3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">         SETATTR3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">         SETATTR3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Процедура SETATTR змінює один або кілька атрибутів об'єкта файлової системи на сервері. Нові атрибути визначено структурою sattr3. На вході аргументи в SETATTR3args такі:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       object</p>
        <p class="Pr_20_Text">          Дескриптор файлу для об'єкта.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       new_attributes</p>
        <p class="Pr_20_Text">          Структура sattr3, що містить логічні значення та перерахування, що описують атрибути, які потрібно встановити, і нові значення для цих атрибутів.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       guard</p>
        <p class="Pr_20_Text">          обʼєднання sattrguard3:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       check</p>
        <p class="Pr_20_Text">          TRUE, якщо сервер повинен перевірити, що guard.obj_ctime відповідає ctime для об’єкта; інакше FALSE.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Клієнт може запросити, щоб сервер перевірив, чи перебуває об’єкт перед виконанням операції SETATTR в очікуваному стані. Для цього він встановлює аргументу guard.check значення TRUE, а клієнт передає значення часу в guard.obj_ctime. Якщо guard.check має значення TRUE, сервер має порівняти значення guard.obj_ctime із поточним ctime об’єкта. Якщо значення відрізняються, сервер повинен зберегти атрибути об’єкта та повернути статус NFS3ERR_NOT_SYNC. Якщо guard.check має значення FALSE, сервер цю перевірку не виконуватиме.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Після успішного повернення SETATTR3res.status має значення NFS3_OK, а SETATTR3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">          obj_wcc</p>
        <p class="Pr_20_Text">             Структура wcc_
            data, що містить старі та нові атрибути для об’єкта.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   В іншому випадку SETATTR3res.status містить повідомлення про помилку, а SETATTR3res.resfail містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">          obj_wcc</p>
        <p class="Pr_20_Text">             Структура wcc_data, що містить старі та нові атрибути для об’єкта.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Механізм guard.check дозволяє клієнту уникнути зміни атрибутів об’єкта на основі застарілих атрибутів. Це не гарантує одноразову семантику. Зокрема, якщо відповідь втрачена, а сервер не виявляє повторної передачі запиту, процедура може завершитися з помилкою NFS3ERR_NOT_SYNC, навіть якщо раніше налаштування атрибута було виконано успішно. Клієнт може спробувати відновитися після цієї помилки, отримавши нові атрибути від сервера та надіславши новий запит SETATTR, використовуючи новий ctime. Клієнт може за бажанням перевірити атрибути, щоб уникнути другого запиту SETATTR, якщо нові атрибути показують, що атрибути вже встановлено належним чином (хоча, можливо, це не був клієнт-ініціатор, який встановив атрибути).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Поле new_attributes.size використовується для запиту зміни розміру файла. Значення 0 спричиняє урізання файлу. Значення, яке менше поточного розміру файлу, спричиняє відкидання даних від нового розміру до кінця файлу, а розм  ір, більший за поточний розмір файлу, спричиняє логічне обнулення байтів даних, які потрібно додати в кінець файлу. Сервери можуть вільно реалізувати це за допомогою дірок або фактичних нульових байтів даних. Клієнти не повинні робити жодних припущень щодо реалізації цієї функції на сервері, крім того, що повернуті байти будуть обнулені. Сервери повинні підтримувати збільшення розміру файлу за допомогою SETATTR.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     SETATTR не гарантує атомарність. Невдалий запит SETATTR може частково змінити атрибути файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Зміна розміру файлу за допомогою SETATTR опосередковано змінює mtime. Клієнт повинен враховувати це, оскільки зміни розміру можуть призвести до видалення даних.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Якщо час серверу та клієнта відрізняється, програми, які порівнюють час клієнта з часом файлу, можуть завершитися крахом. Щоб обмежити розбіжність часу клієнт/сервер, слід використовувати протокол обслуговування часу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     У неоднорідному середовищі цілком можливо, що сервер не зможе підтримувати повний діапазон запитів SETATTR. Помилка NFS3ERR_INVAL може бути повернена, якщо сервер не може зберегти uid або gid у власному представленні uid або gid, відповідно. Якщо сервер може підтримувати лише 32-бітні зсуви та розміри, запит SETATTR на встановлення розміру файлу більшим, ніж може бути представлений у 32-бітах, буде відхилено з цією ж помилкою.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    ERRORS</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_PERM</p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_INVAL</p>
        <p class="Pr_20_Text">      NFS3ERR_NOSPC</p>
        <p class="Pr_20_Text">      NFS3ERR_ROFS</p>
        <p class="Pr_20_Text">      NFS3ERR_DQUOT</p>
        <p class="Pr_20_Text">      NFS3ERR_NOT_SYNC</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    Дивись також CREATE, MKDIR, SYMLINK, MKNOD.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        <p class="P3" id="section_3.3.3">3.3.3 Procedure 3: LOOKUP -  Пошук filename</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      LOOKUP3res NFSPROC3_LOOKUP(LOOKUP3args) = 3;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct LOOKUP3args {</p>
        <p class="Pr_20_Text">           diropargs3  what;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct LOOKUP3resok {</p>
        <p class="Pr_20_Text">           nfs_fh3      object;</p>
        <p class="Pr_20_Text">           post_op_attr obj_attributes;</p>
        <p class="Pr_20_Text">           post_op_attr dir_attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct LOOKUP3resfail {</p>
        <p class="Pr_20_Text">           post_op_attr dir_attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union LOOKUP3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           LOOKUP3resok    resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           LOOKUP3resfail  resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    Процедура LOOKUP шукає в каталозі певне ім’я та повертає дескриптор файлу для відповідного об’єкта файлової системи. Під час входу аргументи в LOOKUP3args є такими:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     what</p>
        <p class="Pr_20_Text">         Object to look up:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         dir</p>
        <p class="Pr_20_Text">            Дескриптор файлу для каталогу, який шукається.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         name</p>
        <p class="Pr_20_Text">            Ім'я файлу для пошуку. Див. Загальні коментарі щодо імен файлів </p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Після успішного повернення LOOKUP3res.status має значення NFS3_OK, а LOOKUP3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      object</p>
        <p class="Pr_20_Text">         Дескриптор файлу об'єкта what.name.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      obj_attributes</p>
        <p class="Pr_20_Text">         Атрибути об'єкта what.name.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir_attributes</p>
        <p class="Pr_20_Text">         Атрибути post-операції каталогу what.dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      В іншому випадку LOOKUP3res.status містить повідомлення про помилку LOOKUP3res.resfail:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir_attributes</p>
        <p class="Pr_20_Text">         Атрибути post-операції для каталогу, what.dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     На перший погляд, у випадку, коли what.name посилається на точку монтування на сервері, можливі дві різні відповіді. Сервер може повернути дескриптор файлу для основного каталогу, який змонтовано, або дескриптор файлу кореня змонтованого каталогу. Ця неоднозначність вирішується просто. Сервер не дозволить операції LOOKUP перейти через точку монтування до кореня іншої файлової системи, навіть якщо файлову систему експортовано. Це не
            заважає клієнту отримати доступ до ієрархії файлових систем, експортованих сервером, але клієнт повинен монтувати кожну з файлових систем окремо, щоб перетин точок монтування відбувався на клієнті. Дана реалізація сервера може уточнювати ці правила відповідно до можливостей або обмежень, характерних для цієї реалізації. Зверніться до [X/OpenNFS] для обговорення експорту файлових систем.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Два імені файлів відзначаються, як у протоколі NFS версії 2. Ім'я "." є псевдонімом поточного каталогу, а ім'я ".." є псевдонімом батьківського каталогу; тобто каталог, який містить у собі вказаний каталог. Немає засобів для роботи з каталогом який має кілька батьків, і протокол NFS передбачає ієрархічну організацію, організовану як однокореневе дерево.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Зауважте, що ця процедура не виконується за символьними посиланнями. Клієнт несе відповідальність за аналіз усіх імен файлів, включаючи імена файлів, змінені символьними посиланнями, які зустрічаються під час процесу пошуку.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_NOENT</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_NAMETOOLONG</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також</p>
        <p class="Pr_20_Text">      CREATE, MKDIR, SYMLINK, MKNOD, READDIRPLUS, and PATHCONF.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        <p class="P3" id="section_3.3.4">3.3.4 Procedure 4: ACCESS - Перевірка дозволу доступа</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      ACCESS3res NFSPROC3_ACCESS(ACCESS3args) = 4;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      const ACCESS3_READ    = 0x0001;</p>
        <p class="Pr_20_Text">      const ACCESS3_LOOKUP  = 0x0002;</p>
        <p class="Pr_20_Text">      const ACCESS3_MODIFY  = 0x0004;</p>
        <p class="Pr_20_Text">      const ACCESS3_EXTEND  = 0x0008;</p>
        <p class="Pr_20_Text">      const ACCESS3_DELETE  = 0x0010;</p>
        <p class="Pr_20_Text">      const ACCESS3_EXECUTE = 0x0020;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct ACCESS3args {</p>
        <p class="Pr_20_Text">           nfs_fh3  object;</p>
        <p class="Pr_20_Text">           uint32   access;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct ACCESS3resok {</p>
        <p class="Pr_20_Text">           post_op_attr   obj_attributes;</p>
        <p class="Pr_20_Text">           uint32         access;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct ACCESS3resfail {</p>
        <p class="Pr_20_Text">           post_op_attr   obj_attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union ACCESS3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           ACCESS3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           ACCESS3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Процедура ACCESS визначає права доступу, які має користувач, як визначено обліковими даними в запиті, щодо об’єкта файлової системи. Клієнт кодує набір дозволів, які потрібно перевірити, у бітовій масці. Сервер перевіряє дозволи, закодовані в бітовій масці. Статус NFS3_OK повертається разом із бітовою маскою, закодованою з permissons, які дозволено клієнту.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Результати цієї процедури є обов'язковими та носять рекомендаційний характер. Тобто статус повернення NFS3_OK і відповідний біт, встановлений у бітовій масці, не означають, що такий доступ буде дозволено до об’єкта файлової системи у майбутньому, оскільки права доступу можуть бути відкликані сервером у будь-який час.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     При вході аргументи в ACCESS3args:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     object</p>
        <p class="Pr_20_Text">        Дескриптор файлу для об'єкта файлової системи, доступ до якого потрібно перевірити.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     access</p>
        <p class="Pr_20_Text">        Бітова маска прав доступу для перевірки.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Наступні дозволи доступу можуть бути запрошені:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">        ACCESS3_READ</p>
        <p class="Pr_20_Text">           Читати дані з файлу або читати каталог.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">        ACCESS3_LOOKUP</p>
        <p class="Pr_20_Text">           Пошук імені в каталозі (не має значення для об’єктів, які не є каталогами).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">        ACCESS3_MODIFY</p>
        <p class="Pr_20_Text">           Перезапис наявних даних файлу або заміна існуючих записів директорії.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">        ACCESS3_EXTEND</p>
        <p class="Pr_20_Text">           Запис нових даних або додавання записів у директорії.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">        ACCESS3_DELETE</p>
        <p class="Pr_20_Text">           Видалити наявний запис у директорії.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">          ACCESS3_EXECUTE</p>
        <p class="Pr_20_Text">             Виконати файл (не має значення для директорії).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Після успішного повернення ACCESS3res.status має значення NFS3_OK. Сервер має повернути статус NFS3_OK, якщо не сталося жодних помилок, які завадили серверу виконати необхідні перевірки доступу. Результати в ACCESS3res.resok:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       obj_attributes</p>
        <p class="Pr_20_Text">          post-операційні атрибути об'єкта.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       access</p>
        <p class="Pr_20_Text">          Бітова маска дозволів доступу, що вказує права доступу для облікових даних автентифікації, наданих із запитом.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     В іншому випадку ACCESS3res.status містить повідомлення про помилку, а ACCESS3res.resfail містить таке:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       obj_attributes</p>
        <p class="Pr_20_Text">          Атрибути об'єкта - якщо доступ до атрибутів дозволено.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Загалом, для клієнта недостатньо спробувати отримати дозволи на доступ, перевіряючи поля uid, gid і mode в атрибутах файлу, оскільки сервер може виконати відображення uid або gid або застосувати додаткові обмеження контролю доступу. Також можливо, що сервер протоколу NFS версії 3 може бути не в тому самому просторі ідентифікаторів, що й клієнт протоколу NFS версії 3. У цих випадках (і, можливо, в інших) клієнт протоколу NFS версії 3 не може надійно виконати перевірку доступу лише з поточними атрибутами файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       У протоколі NFS версії 2 єдиним надійним способом визначити, чи дозволена операція, була спроба виконати її, та побачити, успішно вона завершилася чи невдало. Використовуючи процедуру ACCESS у протоколі NFS версії 3, клієнт може попросити сервер вказати, чи дозволено один чи більше класів операцій. Операція ACCESS надається, щоб дозволити клієнтам перевірку перед виконанням ряду операцій. Це корисно в операційних системах (таких як UNIX), де перевірка дозволів виконується лише тоді, коли відкривається файл або каталог. Ця процедура також викликається процедурою доступу клієнта NFS (можливість визову через access(2)). Мета полягає у тому, щоб зробити поведінку відкриття віддаленого файлу більш узгодженою з поведінкою відкриття локального файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Інформація, яку повертає сервер у відповідь на виклик ACCESS, не є постійною. Це було правильно у той час, коли сервер виконував перевірки, але не обов’язково після цього. Сервер може в будь-який момент відкликати дозвіл на доступ.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Клієнт протоколу NFS версії 3 повинен використовувати ефективні облікові дані користувача для створення інформації автентифікації в запиті ACCESS, який використовується для визначення прав доступу. Це ефективні облікові дані користувача та групи, які використовуються в подальших операціях читання та запису. Перегляньте коментарі в розділі "Проблеми з дозволом", щоб отримати додаткову інформацію на цю тему.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Багато реалізацій безпосередньо не підтримують дозвіл ACCESS3_DELETE. Операційні системи, такі як UNIX, ігноруватимуть біт ACCESS3_DELETE, якщо його встановлено в запиті на доступ до об’єкта, що не є каталогом. У цих системах дозвіл на видалення файлу визначається дозволами доступу до каталогу, у якому знаходиться файл, замість того, щоб визначатись дозволами самого файлу. Таким чином, бітова маска, яка повертається для такого запиту, матиме біт ACCESS3_DELETE, встановлений на 0, що вказує на те, що клієнт не має цього дозволу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ERRORS</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також GETATTR.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        <p class="P3" id="section_3.3.5">3.3.5 Procedure 5: READLINK - Читання з символічного посилання</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      READLINK3res NFSPROC3_READLINK(READLINK3args) = 5;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct READLINK3args {</p>
        <p class="Pr_20_Text">           nfs_fh3  symlink;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct READLINK3resok {</p>
        <p class="Pr_20_Text">           post_op_attr   symlink_attributes;</p>
        <p class="Pr_20_Text">           nfspath3       data;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct READLINK3resfail {</p>
        <p class="Pr_20_Text">           post_op_attr   symlink_attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union READLINK3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           READLINK3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           READLINK3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура READLINK зчитує дані, пов'язані з символічним посиланням. Дані – це рядок ASCII, непрозорий для сервера. Тобто незалежно від того, чи створено посилання програмним забезпеченням протоколу NFS версії 3 на боці клієнта, чи створено локально на сервері, дані в символічному посиланні не інтерпретуються під час створення, а просто зберігаються. На вході аргументи в READLINK3args є такими:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      символічне посилання</p>
        <p class="Pr_20_Text">          Дескриптор файлу для символічного посилання (об'єкт файлової системи типу NF3LNK).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Після успішного повернення READLINK3res.status має значення NFS3_OK, а READLINK3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       data</p>
        <p class="Pr_20_Text">          Дані, пов’язані з символічним посиланням.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       symlink_attributes</p>
        <p class="Pr_20_Text">          Атрибути після операції для символічного посилання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       В іншому випадку READLINK3res.status містить повідомлення про помилку, а READLINK3res.resfail містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       symlink_attributes</p>
        <p class="Pr_20_Text">          Атрибути після операції для символічного посилання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Символічне посилання номінально є вказівком на інший файл. Дані не обов’язково інтерпретуються сервером, вони просто зберігаються у файлі. У символічному посиланні клієнтська реалізація може зберігати ім’я шляху, яке не має сенсу для операційної системи сервера. Операція READLINK повертає дані клієнту для інтерпретації. Якщо різні реалізації хочуть поділитися доступом до символічних посилань, вони повинні узгодити інтерпретацію даних у символьному посиланні.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Операція READLINK дозволена лише для об’єктів типу NF3LNK. Сервер має повернути помилку NFS3ERR_INVAL, якщо об’єкт не має типу NF3LNK. (Примітка: специфікація X/Open XNFS для протоколу NFS версії 2 визначає статус помилки в цьому випадку як NFSERR_NXIO. Це несумісно з існуючою практикою сервера.)</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ERRORS</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_INVAL</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTSUPP</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також READLINK, SYMLINK.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        <p class="P3" id="section_3.3.6">3.3.6 Procedure 6: READ - Читання з файлу</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      READ3res NFSPROC3_READ(READ3args) = 6;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct            READ3args {</p>
        <p class="Pr_20_Text">           nfs_fh3  file;</p>
        <p class="Pr_20_Text">           offset3  offset;</p>
        <p class="Pr_20_Text">           count3   count;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct READ3resok {</p>
        <p class="Pr_20_Text">           post_op_attr   file_attributes;</p>
        <p class="Pr_20_Text">           count3         count;</p>
        <p class="Pr_20_Text">           bool           eof;</p>
        <p class="Pr_20_Text">           opaque         data&lt;&gt;;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct READ3resfail {</p>
        <p class="Pr_20_Text">           post_op_attr   file_attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union READ3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           READ3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           READ3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура READ читає дані з файлу. При вході аргументи в READ3args:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      file</p>
        <p class="Pr_20_Text">          Дескриптор файлу, з якого потрібно зчитати дані. Він має ідентифікувати об’єкт файлової системи типу NF3REG.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      offset</p>
        <p class="Pr_20_Text">          Позиція у файлі, з якої має початися читання. Offset 0 означає читання даних від самого початку файлу. Якщо зміщення більше або дорівнює розміру файлу, повертається статус NFS3_OK із значенням count=0 та значенням eof=TRUE, за умови перевірки прав доступу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      count</p>
        <p class="Pr_20_Text">          Кількість байтів даних, які потрібно прочитати. Якщо count дорівнює 0, READ завершиться успішно та поверне 0 байт даних за умови перевірки прав доступу. count має бути меншим або дорівнювати значенню поля rtmax у структурі відповіді FSINFO для файлової системи, яка містить файл. Якщо більше, сервер може повертати лише rtmax байтів, що призводить до короткого читання (short read).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Після успішного повернення READ3res.status має значення NFS3_OK, а READ3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      file_attributes</p>
        <p class="Pr_20_Text">          Атрибути файлу після завершення читання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      count</p>
        <p class="Pr_20_Text">          Кількість байтів даних, повернутих під час читання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       eof</p>
        <p class="Pr_20_Text">          Якщо читання закінчилося в кінці файлу (формально, у правильно сформованому запиті READ, якщо READ3args.offset плюс READ3resok.count дорівнює розміру файлу), eof повертається як TRUE; інакше це FALSE. Успішне ЧИТАННЯ порожнього файлу завжди повертатиме eof як TRUE.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       data</p>
        <p class="Pr_20_Text">          Підраховані дані, які зчитані з файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       В іншому випадку READ3res.status містить повідомлення про помилку, а READ3res.resfail містить таке:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       file_attributes</p>
        <p class="Pr_20_Text">          Атрибути файлу після операції.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Тип nfsdata, який використовується для операцій READ і WRITE у протоколі NFS версії 2, що визначає частину даних запиту або відповіді, було змінено на непрозорий байтовий масив змінної довжини. Максимальний розмір, дозволений протоколом, тепер обмежений розміром, що дозволяє XDR і основні транспортні засоби. Протокол NFS версії 3 не накладає жодних штучних обмежень. Докладніше див. в описі процедури FSINFO.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Сервер може повернути менше байтів даних ніж значення count. Якщо сервер повертає кількість, меншу за запитану, та eof має значення FALSE, клієнт повинен виконати ще одне READ, щоб отримати решту даних. За деяких обставин сервер може повернути менше даних, ніж запитувано. Можливо, файл був скорочений іншим клієнтом або, можливо, на самому сервері було змінено розмір файлу порівняно з тим, що запитує клієнт. Це може зменшити фактичний обсяг даних, доступних клієнту. Можливо, сервер може зменшити розмір передачі та зменшити результат запиту на читання. Також може виникнути виснаження ресурсів сервера, що потребуватиме меншого результату читання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Деякі клієнтські реалізації протоколу NFS версії 2 інтерпретують коротку відповідь на читання як вказівку EOF. Додавання прапорця eof до протоколу NFS версії 3 забезпечує правильний спосіб обробки EOF.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Деякі реалізації сервера протоколу NFS версії 2 неправильно повертали NFSERR_ISDIR, якщо тип об’єкта файлової системи не був звичайним файлом. Правильним значенням, що повертається для протоколу NFS версії 3, є NFS3ERR_INVAL.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_NXIO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_INVAL</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також READLINK.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        <p class="P3" id="section_3.3.7">3.3.7 Procedure 7: WRITE - Write to file</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      WRITE3res NFSPROC3_WRITE(WRITE3args) = 7;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      enum stable_how {</p>
        <p class="Pr_20_Text">           UNSTABLE  = 0,</p>
        <p class="Pr_20_Text">           DATA_SYNC = 1,</p>
        <p class="Pr_20_Text">           FILE_SYNC = 2</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct WRITE3args {</p>
        <p class="Pr_20_Text">           nfs_fh3     file;</p>
        <p class="Pr_20_Text">           offset3     offset;</p>
        <p class="Pr_20_Text">           count3      count;</p>
        <p class="Pr_20_Text">           stable_how  stable;</p>
        <p class="Pr_20_Text">           opaque      data&lt;&gt;;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct WRITE3resok {</p>
        <p class="Pr_20_Text">           wcc_data    file_wcc;</p>
        <p class="Pr_20_Text">           count3      count;</p>
        <p class="Pr_20_Text">           stable_how  committed;</p>
        <p class="Pr_20_Text">           writeverf3  verf;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct WRITE3resfail {</p>
        <p class="Pr_20_Text">           wcc_data    file_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union WRITE3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           WRITE3resok    resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           WRITE3resfail  resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура WRITE записує дані у файл. WRITE3args приймає такі аргументи:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      файл</p>
        <p class="Pr_20_Text">        Дескриптор файлу, до якого мають бути записані дані. Він має ідентифікувати об’єкт файлової системи типу NF3REG.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      offset</p>
        <p class="Pr_20_Text">        Позиція у файлі, з якої має початися запис. Зміщення 0 означає запис даних с початку файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      count</p>
        <p class="Pr_20_Text">        Кількість байтів даних для запису. Якщо count дорівнює 0, WRITE завершиться успішно та поверне count 0, за винятком помилок перевірки дозволів. Розмір даних має бути меншим або дорівнювати значенню поля wtmax у структурі відповіді FSINFO для файлової системи, яка містить файл. Якщо більше, сервер може записувати лише wtmax байтів, що призводить до короткого запису (short write).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      stable</p>
        <p class="Pr_20_Text">        Якщо stable є FILE_SYNC, сервер перед поверненням результатів має зафіксувати записані дані та всі метадані файлової системи до стабільного сховища. Це відповідає семантиці протоколу NFS версії 2. Будь-яка інша поведінка є порушенням протоколу. Якщо для параметра stable встановлено значення DATA_SYNC, тоді сервер повинен передати всі data0 у стабільне сховище та достатню кількість метаданих для отримання даних перед поверненням. Розробник сервера може вільно реалізувати DATA_SYNC так само, як FILE_SYNC, але з можливим падінням продуктивності. Якщо параметр stable має значення UNSTABLE, перш ніж повернути відповідь клієнту сервер може зафіксувати будь-яку частину даних і метаданих у стабільному сховищі, включаючи все або нічого. Немає жодної гарантії, що незафіксовані дані будуть згодом зафіксовані у стабільному сховищі. Сервер гарантує лише те, що він не знищить жодних даних без зміни значення verf, і що він не зафіксує дані та метадані на рівні, нижчому від того, який вимагає клієнт. Перегляньте обговорення COMMIT для отримання додаткової інформації про те, за яких умов і коли фіксуються дані для стабільного зберігання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       data</p>
        <p class="Pr_20_Text">          Дані, які потрібно записати у файл.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Після успішного повернення WRITE3res.status має значення NFS3_OK, а WRITE3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       file_wcc</p>
        <p class="Pr_20_Text">          Слабкі дані узгодженості кешу для файлу. Для клієнта, якому потрібні лише атрибути файлу після запису, їх можна знайти у file_wcc.after.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      count</p>
        <p class="Pr_20_Text">          Кількість байтів даних, записаних у файл. Сервер може записати менше байтів, ніж вимагається. Якщо так, то повертається фактична кількість байтів, записаних, починаючи з розташування offset.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      committed</p>
        <p class="Pr_20_Text">          Сервер має повернути індикатор рівня збереженості даних і метаданих через committed. Якщо сервер зафіксував усі дані та метадані в стабільному сховищі, для параметра committed має бути встановлено значення FILE_SYNC. Якщо рівень передачі був принаймні такого ж рівня як DATA_SYNC, тоді для параметра committed має бути встановлено DATA_SYNC. В іншому випадку committed має бути повернуто як UNSTABLE. Якщо stable був FILE_SYNC, то committed також має бути FILE_SYNC: усе інше є порушенням протоколу. Якщо stable був DATA_SYNC, то committed може бути FILE_SYNC або DATA_SYNC: все інше є порушенням протоколу. Якщо stable був UNSTABLE, то committed може бути FILE_SYNC, DATA_SYNC або UNSTABLE.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       verf</p>
        <p class="Pr_20_Text">          Це файл cookie, за допомогою якого клієнт може визначити, чи змінив сервер стан між викликом WRITE та наступним викликом WRITE або COMMIT. Цей файл cookie має бути узгодженим протягом роботи одного екземпляра служби протоколу NFS версії 3 і має бути унікальним між екземплярами сервера протоколу NFS версії 3, де незафіксовані дані можуть бути втрачені.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       В іншому випадку WRITE3res.status містить інформацію про помилку, WRITE3res.resfail містить наступне:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       file_wcc</p>
        <p class="Pr_20_Text">          Слабка узгодженость кешa і даних у файлі. Для клієнта, якому потрібні лише атрибути файлу після запису, їх можна знайти у file_wcc.after. Навіть якщо запис був невдалим, повертається повний wcc_data, щоб дозволити клієнту визначити, чи спричинив невдалий запис будь-які зміни у файлі.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Якщо клієнт записує дані на сервер зі stable аргументом, установленим в UNSTABLE, і відповідь повертає зафіксовану відповідь DATA_SYNC або UNSTABLE, клієнт через деякий час у майбутньому виконає операцію COMMIT, щоб синхронізувати незавершені асинхронні дані та метадані у стабільне сховище сервера, за винятком помилки клієнта. Можливо, що через збій клієнта чи іншу помилку наступний COMMIT не буде отримано сервером.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Тип nfsdata, що визначає частину даних запиту або відповіді, який використовується для операцій READ і WRITE у протоколі NFS версії 2, було змінено на непрозорий байтовий масив змінної довжини. Максимальний розмір, дозволений протоколом, тепер обмежений тим, що дозволяє XDR і основні транспортні засоби. Протокол NFS версії 3 не накладає жодних штучних обмежень. Докладніше див. в описі процедури FSINFO.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Сервер може записати менше count байтів даних. У цьому випадку сервер не повинен повертати помилку, якщо дані не були записані взагалі. Якщо сервер записує менше байтів, ніж count байтів, клієнт повинен виконати ще один запит WRITE, щоб записати решту даних.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Передбачається, що операціяі запису даних у файл призведе до оновлення mtime файлу. Однак mtime файлу не слід змінювати, якщо не змінено вміст файлу. Таким чином, запит WRITE з count, встановленим у 0, не повинен викликати оновлення mtime файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Протокол NFS версії 3 забезпечує безпечний асинхронний запис. Комбінація WRITE зі stable значенням  UNSTABLE з наступним COMMIT усуває вузьке місце, виявлене в протоколі NFS версії 2, а саме потребу синхронно фіксувати всі записи до стабільного сховища.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Визначення "стабільне зберігання" історично було предметом суперечок. Наступні очікувані властивості стабільного сховища можуть допомогти у вирішенні проектних проблем у реалізації. Стабільне сховище – це постійне сховище, яке витримує:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       1. Повторні збої електроенергії.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       2. Апаратні збої (будь-якої плати, блоку живлення і так далі).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       3. Повторні збої програмного забезпечення, включаючи цикл перезавантаження.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Це визначення не стосується відмови самого стабільного модуля зберігання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Сookie verf, визначено, щоб дозволити клієнту виявляти різні екземпляри сервера протоколу NFS версії 3, на якому можуть бути втрачені кешовані незафіксовані дані. У найбільш ймовірному випадку verf дозволяє клієнту виявляти перезавантаження сервера. Ця інформація потрібна, щоб клієнт міг безпечно визначити, чи міг сервер втратити кешовані дані. Якщо сервер несподівано виходить з ладу, а клієнт має незафіксовані дані з попередніх запитів WRITE (виконано з аргументом stable, встановленим у UNSTABLE, і в якому зафіксований результат також повертається як UNSTABLE), можливо, сервер не скинув кешовані дані до стабільного сховища. Тому проблема відновлення лежить на клієнті, і клієнту потрібно буде повторно передати дані на сервер.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Запропонований файл cookie verf передбачає використання часу завантаження сервера або часу останнього запуску сервера (якщо перезапуск сервера без перезавантаження призводить до втрати буферів).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Закріплене поле в результатах дозволяє клієнту виконувати більш ефективне кешування. Якщо сервер надсилає всі запити WRITE до стабільного сховища, тоді він має повернутися зі встановленим set FILE_SYNC, незалежно від значення поля stable в аргументах. Сервер, який використовує прискорювач NVRAM, може застосувати цю політику. Клієнт може використовувати це для підвищення ефективності кешу, відкидаючи кешовані дані, які вже були зафіксовані на сервері.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Деякі реалізації можуть повертати NFS3ERR_NOSPC замість NFS3ERR_DQUOT, коли перевищенa квота користувача.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Деякі реалізації сервера протоколу NFS версії 2 неправильно повертали NFSERR_ISDIR, якщо тип об’єкта файлової системи не був звичайним файлом. Правильним значенням, що повертається для протоколу NFS версії 3, є NFS3ERR_INVAL.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_FBIG</p>
        <p class="Pr_20_Text">      NFS3ERR_DQUOT</p>
        <p class="Pr_20_Text">      NFS3ERR_NOSPC</p>
        <p class="Pr_20_Text">      NFS3ERR_ROFS</p>
        <p class="Pr_20_Text">      NFS3ERR_INVAL</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також COMMIT.</p>
        <p class="Pr_20_Text"> </p>
        
        <p class="P3" id="section_3.3.8">3.3.8 Procedure 8: CREATE - Створити файл</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      CREATE3res NFSPROC3_CREATE(CREATE3args) = 8;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      enum createmode3 {</p>
        <p class="Pr_20_Text">           UNCHECKED = 0,</p>
        <p class="Pr_20_Text">           GUARDED   = 1,</p>
        <p class="Pr_20_Text">           EXCLUSIVE = 2</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union createhow3 switch (createmode3 mode) {</p>
        <p class="Pr_20_Text">      case UNCHECKED:</p>
        <p class="Pr_20_Text">      case GUARDED:</p>
        <p class="Pr_20_Text">           sattr3       obj_attributes;</p>
        <p class="Pr_20_Text">      case EXCLUSIVE:</p>
        <p class="Pr_20_Text">           createverf3  verf;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct CREATE3args {</p>
        <p class="Pr_20_Text">           diropargs3   where;</p>
        <p class="Pr_20_Text">           createhow3   how;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct CREATE3resok {</p>
        <p class="Pr_20_Text">           post_op_fh3   obj;</p>
        <p class="Pr_20_Text">           post_op_attr  obj_attributes;</p>
        <p class="Pr_20_Text">           wcc_data      dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct CREATE3resfail {</p>
        <p class="Pr_20_Text">           wcc_data      dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union CREATE3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           CREATE3resok    resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           CREATE3resfail  resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Процедура CREATE створює звичайний файл. На вході аргументи в CREATE3args:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       where</p>
        <p class="Pr_20_Text">          Розташування файлу, який буде створено:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir</p>
        <p class="Pr_20_Text">          Дескриптор файлу для директорії, у якому буде створено файл.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       name</p>
        <p class="Pr_20_Text">          Ім'я, яке буде пов'язано зі створеним файлом. Дивись "Загальні коментарі щодо імен файлів".</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Під час створення звичайного файлу є три способи створити файл, які визначють:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       how</p>
        <p class="Pr_20_Text">         обʼєднання відмінностей, що описує, як сервер має обробляти створення файлу разом із відповідними атрибутами:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       mode</p>
        <p class="Pr_20_Text">          Один з UNCHECKED, GUARDED та EXCLUSIVE. UNCHECKED означає, що файл має бути створено без перевірки наявності дубліката файлу у тій самій директорії. У цьому випадку how.obj_attributes є sattr3, що описує початкові атрибути для файлу. GUARDED вказує, що сервер повинен перевірити наявність дублікатів файлів перед виконанням операції створення та повинен не виконати запит із помилкою NFS3ERR_EXIST, якщо дублікат файлу існує. Якщо файл не існує, запит виконується як у режимі UNCHECKED. Режим EXCLUSIVE вказує, що сервер повинен дотримуватися семантики ексклюзивного створення, використовуючи верифікатор для забезпечення ексклюзивного створення мети. У цьому випадку не можна надавати атрибути, оскільки сервер може використовувати метадані цільового файлу для зберігання верифікатора createverf3.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Після успішного повернення CREATE3res.status має значення NFS3_
            OK, а результати в CREATE3res.resok такі:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       obj</p>
        <p class="Pr_20_Text">          Дескриптор щойно створеного звичайного файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      obj_attributes</p>
        <p class="Pr_20_Text">          Атрибути щойно створеного звичайного файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_wcc</p>
        <p class="Pr_20_Text">          Слабка узгодженость даних кешу для директорії where.dir. Клієнта, якому потрібні атрибути директорії post-CREATE, мож знайти їх у dir_wcc.after.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       В іншому випадку CREATE3res.status містить повідомлення про помилку, а CREATE3res.resfail містить таке:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_wcc</p>
        <p class="Pr_20_Text">          Слабка узгодженость даних кешу для директорії where.dir. Для клієнта, якому потрібні лише атрибути каталогу post-CREATE, їх можна знайти в dir_wcc.after. Незважаючи на невдачу CREATE, повертається повний wcc_data, щоб дозволити клієнту визначити, чи призвела помилка CREATE до будь-яких змін у директорії.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       На відміну від протоколу NFS версії 2, у якому певні поля початкової структури атрибутів були перевантажені заради створення пристроїв і FIFO на додаток до звичайних файлів, ця процедура підтримує лише створення звичайних файлів. Процедура MKNOD була представлена в протоколі NFS версії 3 для створення пристроїв і FIFO. Реалізації в протоколі NFS версії 3 не повинні мати причини перевантажувати семантику CREATE.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Один аспект процедури CREATE протоколу NFS версії 3 вимагає особливо ретельного розгляду: механізм, запроваджений для підтримки надійного ексклюзивного створення звичайних файлів. Механізм вступає в дію, коли how.mode є EXCLUSIVE. У цьому випадку how.verf містить верифікатор, який можна обґрунтовано вважати унікальним. Доречною може бути комбінація ідентифікатора клієнта, можливо, мережевої адреси клієнта, та унікального номера, згенерованого клієнтом, можливо, ідентифікатора транзакції RPC.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Якщо файл не існує, сервер створює файл і зберігає верифікатор у стабільному сховищі. Для файлових систем, які не забезпечують механізм зберігання довільних атрибутів файлу, сервер може використовувати один або більше елементів метаданих файлу для зберігання верифікатора. Верифікатор повинен зберігатися в стабільному сховищі, щоб запобігти помилковій помилці під час повторної передачі запиту. Передбачається, що виконується ексклюзивне створення, оскільки ексклюзивна семантика є критичною для програми. Через очікуване використання ексклюзивний CREATE не покладається виключно на зазвичай непостійний кеш дублікатів запитів для зберігання верифікатора. Дубльований кеш запитів у енергозалежному сховищі не витримає краху та може фактично бути скинутим на довгому розділі мережі, відкриваючи вікна помилок. У середовищі локальної файлової системи UNIX очікуваним місцем зберігання верифікатора під час створення є метадані (мітки часу) файлу. З цієї причини ексклюзивне створення файлу може не містити початкових атрибутів, оскільки сервер не матиме місця для зберігання верифікатора.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Якщо сервер не може підтримувати цю ексклюзивну семантику створення, можливо, через вимогу закріпити верифікатор у стабільному сховищі, запит CREATE не виконується з помилкою NFS3ERR_NOTSUPP.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Під час ексклюзивного запиту CREATE, якщо файл вже існує, сервер реконструює верифікатор файлу та порівнює його з верифікатором у запиті. Якщо вони збігаються, сервер розглядає запит як успішний. Вважається, що запит є дублікатом попереднього успішного запиту, відповідь на який було втрачено, і механізм кешу сервера дублікатів запитів не виявив. Якщо верифікатори не збігаються, запит відхиляється зі статусом NFS3ERR_EXIST.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Після того, як клієнт виконав успішне ексклюзивне створення, він повинен видати SETATTR, щоб встановити правильні атрибути файлу. Поки він цього не зробить, він не повинен покладатися на жоден із атрибутів файлу, оскільки реалізація сервера може потребувати перевантаження метаданих файлу для зберігання верифікатора.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Використання атрибута GUARDED не забезпечує одноразової семантики. Зокрема, якщо відповідь втрачена, а сервер не виявляє спроби повторної передачі запиту, процедура може завершитися помилкою з NFS3ERR_EXIST, навіть якщо створення виконано успішно.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Див. "Загальні коментарі щодо імен файлів".</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_EXIST</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_NOSPC</p>
        <p class="Pr_20_Text">      NFS3ERR_ROFS</p>
        <p class="Pr_20_Text">      NFS3ERR_NAMETOOLONG</p>
        <p class="Pr_20_Text">      NFS3ERR_DQUOT</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTSUPP</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також MKDIR, SYMLINK, MKNOD, and PATHCONF.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.9">3.3.9 Procedure 9: MKDIR - Створення директорії</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      MKDIR3res NFSPROC3_MKDIR(MKDIR3args) = 9;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct MKDIR3args {</p>
        <p class="Pr_20_Text">           diropargs3   where;</p>
        <p class="Pr_20_Text">           sattr3       attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct MKDIR3resok {</p>
        <p class="Pr_20_Text">           post_op_fh3   obj;</p>
        <p class="Pr_20_Text">           post_op_attr  obj_attributes;</p>
        <p class="Pr_20_Text">           wcc_data      dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct MKDIR3resfail {</p>
        <p class="Pr_20_Text">           wcc_data      dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union MKDIR3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           MKDIR3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           MKDIR3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура MKDIR створює новий підкаталог. На вході аргументи в MKDIR3args такі:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      where</p>
        <p class="Pr_20_Text">          Розташування підкаталогу, який буде створено:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir</p>
        <p class="Pr_20_Text">         Ідентифікатор файлу для каталогу, у якому буде створено підкаталог.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      name</p>
        <p class="Pr_20_Text">         Ім'я, яке буде пов'язано зі створеним підкаталогом. Див. "Загальні коментарі щодо імен файлів"</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      attributes</p>
        <p class="Pr_20_Text">          Початкові атрибути для підкаталогу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Після успішного повернення MKDIR3res.status має значення NFS3_OK, а результати в MKDIR3res.resok такі:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      object</p>
        <p class="Pr_20_Text">          Дескриптор файлу для новоствореного каталогу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       obj_attributes</p>
        <p class="Pr_20_Text">          Атрибути новоствореного підкаталогу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_wcc</p>
        <p class="Pr_20_Text">          Слабкa узгодженість кеша даних для каталогу where.dir. Для клієнта, якому потрібні лише атрибути каталогу post-MKDIR, їх можна знайти в dir_wcc.after.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       В іншому випадку MKDIR3res.status містить повідомлення про помилку, а MKDIR3res.resfail містить таке:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_wcc</p>
        <p class="Pr_20_Text">          Слабкa узгодженість кеша даних для каталогу where.dir. Для клієнта, якому потрібні лише атрибути каталогу post-MKDIR, їх можна знайти в dir_wcc.after. Навіть якщо MKDIR не виконався, повертається повний wcc_data, щоб дозволити клієнту визначити, чи спричинив збій MKDIR будь-які зміни в каталозі.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Багато реалізацій сервера не допускають імен файлів "." або "..", для використання як цілі в операції MKDIR. У цьому випадку сервер повинен повернути NFS3ERR_EXIST. Див. "Загальні коментарі щодо імен файлів"</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_EXIST</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_NOSPC</p>
        <p class="Pr_20_Text">      NFS3ERR_ROFS</p>
        <p class="Pr_20_Text">      NFS3ERR_NAMETOOLONG</p>
        <p class="Pr_20_Text">      NFS3ERR_DQUOT</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTSUPP</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також CREATE, SYMLINK, MKNOD, PATHCONF.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.10">3.3.10 Procedure 10: SYMLINK - Створити символічне посилання</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      SYMLINK3res NFSPROC3_SYMLINK(SYMLINK3args) = 10;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct symlinkdata3 {</p>
        <p class="Pr_20_Text">           sattr3    symlink_attributes;</p>
        <p class="Pr_20_Text">           nfspath3  symlink_data;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct SYMLINK3args {</p>
        <p class="Pr_20_Text">           diropargs3    where;</p>
        <p class="Pr_20_Text">           symlinkdata3  symlink;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct SYMLINK3resok {</p>
        <p class="Pr_20_Text">           post_op_fh3   obj;</p>
        <p class="Pr_20_Text">           post_op_attr  obj_attributes;</p>
        <p class="Pr_20_Text">           wcc_data      dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct SYMLINK3resfail {</p>
        <p class="Pr_20_Text">           wcc_data      dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union SYMLINK3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           SYMLINK3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           SYMLINK3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура SYMLINK створює нове символічне посилання. На вході аргументи в SYMLINK3args такі:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      where</p>
        <p class="Pr_20_Text">        Розташування символічного посилання, яке буде створено:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir</p>
        <p class="Pr_20_Text">        Дескриптор файлу для каталогу, у якому буде створено символічне посилання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">        name</p>
        <p class="Pr_20_Text">          Ім'я, яке буде пов'язано зі створеним символічним посиланням. Дивись "Загальні коментарі щодо імен файлів"</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      symlink</p>
        <p class="Pr_20_Text">        Символьне посилання для створення:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">        symlink_attributes</p>
        <p class="Pr_20_Text">             Початкові атрибути для символічного посилання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">        symlink_data</p>
        <p class="Pr_20_Text">             Рядок, що містить дані символічного посилання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Після успішного повернення SYMLINK3res.status має значення NFS3_OK, а SYMLINK3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      object</p>
        <p class="Pr_20_Text">         Дескриптор файлу для щойно створеного символічного посилання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       obj_attributes</p>
        <p class="Pr_20_Text">         Атрибути для щойно створеного символічного посилання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_wcc</p>
        <p class="Pr_20_Text">         Слабка узгодженость кеша даних для каталогу, where.dir. Для клієнта, якому потрібні лише атрибути каталогу post-SYMLINK, їх можна знайти в dir_wcc.after.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       В іншому випадку SYMLINK3res.status містить повідомлення про помилку, а SYMLINK3res.resfail містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_wcc</p>
        <p class="Pr_20_Text">          Слабка узгодженость кеша даних для каталогу, where.dir. Для клієнта, якому потрібні лише атрибути каталогу post-SYMLINK, їх можна знайти в dir_wcc.after. Навіть якщо SYMLINK не виконався, повертається повний wcc_data, щоб дозволити клієнту визначити, чи змінив каталог невдалий SYMLINK.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   
            РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Дивись "Загальні коментарі щодо імен файлів"</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Для символічних посилань фактичний вузол файлової системи та його вміст повинні бути створені в одній атомарній операції. Тобто, як тільки символічне посилання стає видимим, не повинно бути вікна, де READLINK не спрацює або поверне некорректні дані.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_EXIST</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_NOSPC</p>
        <p class="Pr_20_Text">      NFS3ERR_ROFS</p>
        <p class="Pr_20_Text">      NFS3ERR_NAMETOOLONG</p>
        <p class="Pr_20_Text">      NFS3ERR_DQUOT</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTSUPP</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також READLINK, CREATE, MKDIR, MKNOD, FSINFO, and PATHCONF.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.11">3.3.11 Procedure 11: MKNOD - Створити спеціальний пристрій (device)</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      MKNOD3res NFSPROC3_MKNOD(MKNOD3args) = 11;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct devicedata3 {</p>
        <p class="Pr_20_Text">           sattr3     dev_attributes;</p>
        <p class="Pr_20_Text">           specdata3  spec;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union mknoddata3 switch (ftype3 type) {</p>
        <p class="Pr_20_Text">      case NF3CHR:</p>
        <p class="Pr_20_Text">      case NF3BLK:</p>
        <p class="Pr_20_Text">           devicedata3  device;</p>
        <p class="Pr_20_Text">      case NF3SOCK:</p>
        <p class="Pr_20_Text">      case NF3FIFO:</p>
        <p class="Pr_20_Text">           sattr3       pipe_attributes;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           void;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct MKNOD3args {</p>
        <p class="Pr_20_Text">           diropargs3   where;</p>
        <p class="Pr_20_Text">           mknoddata3   what;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct MKNOD3resok {</p>
        <p class="Pr_20_Text">           post_op_fh3   obj;</p>
        <p class="Pr_20_Text">           post_op_attr  obj_attributes;</p>
        <p class="Pr_20_Text">           wcc_data      dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct MKNOD3resfail {</p>
        <p class="Pr_20_Text">           wcc_data      dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union MKNOD3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           MKNOD3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           MKNOD3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     Процедура MKNOD створює новий спеціальний файл типу what.type. Спеціальними файлами можуть бути файли пристроїв або іменовані канали. MKNOD3args приймає такі аргументи:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     where</p>
        <p class="Pr_20_Text">       Розташування спеціального файлу, який буде створено:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir</p>
        <p class="Pr_20_Text">          Дескриптор файлу для каталогу, у якому буде створено спеціальний файл.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       name</p>
        <p class="Pr_20_Text">          Ім'я, яке буде пов'язано зі створеним спеціальним файлом. Див. "Загальні коментарі щодо імен файлів"</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       what</p>
        <p class="Pr_20_Text">          Дискримінованe об’єднання, що визначає тип спеціального файлу, який буде створено, а також дані й атрибути, що відповідають типу спеціального файлa:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       type</p>
        <p class="Pr_20_Text">           Тип створюваного об'єкта.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Коли створюється спеціальний символьний файл (what.type — NF3CHR) або блоковий спеціальний файл (what.type — NF3BLK) він включає:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       device</p>
        <p class="Pr_20_Text">         Структура devicedata3 з такими компонентами:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         dev_attributes</p>
        <p class="Pr_20_Text">            Початкові атрибути для спеціального файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         spec</p>
        <p class="Pr_20_Text">            Головне число, що зберігається в device.spec.specdata1, і другорядне число, що зберігається в device.spec.specdata2.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Коли створюється сокет (what.type — NF3SOCK) або FIFO (what.type — NF3FIFO), він включає:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         pipe_attributes</p>
        <p class="Pr_20_Text">             Початкові атрибути для спеціального файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Після успішного повернення MKNOD3res.status має значення NFS3_OK, а MKNOD3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       object</p>
        <p class="Pr_20_Text">          Дескриптор файлу для щойно створеного спеціального файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       obj_attributes</p>
        <p class="Pr_20_Text">          Атрибути для щойно створеного спеціального файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_wcc</p>
        <p class="Pr_20_Text">          Слабка узгодженость кеша даних для каталогу where.dir. Для клієнта, якому потрібні лише атрибути каталогу post-MKNOD, їх можна знайти в dir_wcc.after.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       В іншому випадку MKNOD3res.status містить повідомлення про помилку, а MKNOD3res.resfail містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_wcc</p>
        <p class="Pr_20_Text">          Слабка узгодженость кеша даних для каталогу where.dir, where.dir. Для клієнта, якому потрібні лише атрибути каталогу post-MKNOD, їх можна знайти в dir_wcc.after. Навіть якщо MKNOD не виконався, повертається повний wcc_data, щоб дозволити клієнту визначити, чи змінив каталог невдалий MKNOD.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Дивись "Загальні коментарі щодо імен файлів"</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Без явної підтримки створення спеціального типу файлу в протоколі NFS версії 2 поля в аргументах CREATE були перевантажені, щоб вказати створення певних типів об’єктів. Це перевантаження не є необхідним у протоколі NFS версії 3.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Якщо сервер не підтримує жоден із визначених типів, має бути повернена помилка NFS3ERR_NOTSUPP. В іншому випадку, якщо сервер не підтримує цільовий тип або цільовий тип є недопустимим, має бути повернута помилка NFS3ERR_BADTYPE. Зверніть увагу, що NF3REG, NF3DIR і NF3LNK є недозволеними типами для MKNOD. Замість MKNOD для створення цих типів файлів слід використовувати процедури CREATE, MKDIR і SYMLINK відповідно.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_EXIST</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_NOSPC</p>
        <p class="Pr_20_Text">      NFS3ERR_ROFS</p>
        <p class="Pr_20_Text">      NFS3ERR_NAMETOOLONG</p>
        <p class="Pr_20_Text">      NFS3ERR_DQUOT</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTSUPP</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text">      NFS3ERR_BADTYPE</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також CREATE, MKDIR, SYMLINK, and PATHCONF.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.12">3.3.12 Procedure 12: REMOVE - Видалити файл</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      REMOVE3res NFSPROC3_REMOVE(REMOVE3args) = 12;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct REMOVE3args {</p>
        <p class="Pr_20_Text">           diropargs3  object;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct REMOVE3resok {</p>
        <p class="Pr_20_Text">           wcc_data    dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct REMOVE3resfail {</p>
        <p class="Pr_20_Text">           wcc_data    dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union REMOVE3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           REMOVE3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           REMOVE3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура REMOVE видаляє (стирає) запис із каталогу. Якщо запис у каталозі був останнім посиланням на відповідний об’єкт файлової системи, об’єкт може бути знищено. REMOVE3args приймає такі аргументи:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      object</p>
        <p class="Pr_20_Text">         Структура diropargs3, що визначає запис, який потрібно видалити:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir</p>
        <p class="Pr_20_Text">         Дескриптор файлу для каталогу, з якого потрібно видалити запис.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      name</p>
        <p class="Pr_20_Text">         Назва запису, який буде видалено. Дивись "Загальні коментарі щодо імен файлів"</p>
        <p class="Preformatted_20_Text"> </p>
        <p class="Pr_20_Text">      Після успішного повернення REMOVE3res.status має значення NFS3_OK, а REMOVE3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir_wcc</p>
        <p class="Pr_20_Text">         Слабка узгодженость кеша даних для каталогу object.dir. Для клієнта, якому потрібні лише атрибути каталогу post-REMOVE, їх можна знайти в dir_wcc.after.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       В іншому випадку REMOVE3res.status містить повідомлення про помилку, а REMOVE3res.resfail містить таке:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_wcc</p>
        <p class="Pr_20_Text">         Слабка узгодженость кеша даних для каталогу object.dir. Для клієнта, якому потрібні лише атрибути каталогу post-REMOVE, їх можна знайти в dir_wcc.after. Навіть якщо REMOVE не виконався, повертається повний wcc_data, щоб дозволити клієнту визначити, чи змінило каталог невдале REMOVE.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Загалом REMOVE призначено для видалення файлів об’єктів, які не є каталогами, а RMDIR – для видалення каталогів. Однак REMOVE можна використати для видалення каталогів з урахуванням обмежень, накладених інтерфейсом клієнта або сервера. Це було джерелом плутанини в протоколі NFS версії 2.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Концепція останнього посилання залежить від сервера. Однак, якщо поле nlink у попередніх атрибутах об’єкта мало значення 1, клієнт не повинен покладатися на посилання на об’єкт через дескриптор файлу. Подібним чином клієнт не повинен покладатися на те, що ресурси (дисковий простір, запис каталогу тощо), які були раніше пов’язані з об’єктом, стають негайно доступними. Тож, якщо клієнту потрібно мати можливість продовжувати доступ до файлу після виконання REMOVE для його видалення, клієнт повинен вжити заходів, щоб переконатися, що файл все ще буде доступним. Зазвичай використовується механізм RENAME для перейменування файлу зі старого імені на нове приховане ім’я.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Дивись "Загальні коментарі щодо імен файлів"</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_NOENT</p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_NAMETOOLONG</p>
        <p class="Pr_20_Text">      NFS3ERR_ROFS</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також RMDIR, RENAME.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.13">3.3.13 Procedure 13: RMDIR - Remove a Directory</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      RMDIR3res NFSPROC3_RMDIR(RMDIR3args) = 13;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct RMDIR3args {</p>
        <p class="Pr_20_Text">           diropargs3  object;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct RMDIR3resok {</p>
        <p class="Pr_20_Text">           wcc_data    dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct RMDIR3resfail {</p>
        <p class="Pr_20_Text">           wcc_data    dir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union RMDIR3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           RMDIR3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           RMDIR3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">  ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура RMDIR видаляє (стирає) піддиректорію з директорії. Якщо запис піддиректорії у директорії є останнім посиланням на піддерикторію, піддерикторія може бути знищена. RMDIR3args приймає такі аргументи:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      object</p>
        <p class="Pr_20_Text">         Структура diropargs3, яка визначає запис директорії, яку потрібно видалити:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir</p>
        <p class="Pr_20_Text">         Дескриптор файлу для директорії, з якої потрібно видалити піддерикторію.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      name</p>
        <p class="Pr_20_Text">         Ім'я піддерикторії, яку потрібно видалити. Дивись "Загальні коментарі щодо імен файлів".</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Після успішного виконання RMDIR3res.status має значення NFS3_OK, а RMDIR3res.resok містить:   </p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir_wcc</p>
        <p class="Pr_20_Text">         Слабка узгодженність кеша даних для директорії object.dir. Для клієнта, якому потрібні лише атрибути каталогу post-RMDIR, їх можна знайти в dir_wcc.after.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       В іншому випадку RMDIR3res.status містить повідомлення про помилку, а RMDIR3res.resfail містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_wcc</p>
        <p class="Pr_20_Text">         Слабка узгодженність кеша даних для директорії object.dir. Для клієнта, якому потрібні лише атрибути каталогу post-RMDIR, їх можна знайти в dir_wcc.after. Зауважте, що незважаючи на помилку RMDIR, повертається повний wcc_data, щоб дозволити клієнту визначити, чи змінив RMDIR директорію .</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Зауважте, що на деяких серверах видалення непорожнього каталогу заборонено.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      На деяких серверах назва файлу "." є неприпустимою. Ці сервери повернуть помилку NFS3ERR_INVAL. На деяких серверах назва файлу ".." є неприпустимою. Такі сервери повернуть помилку NFS3ERR_EXIST. Це здається суперечливим, але дозволяє цим серверам відповідати своїм власним специфічним визначенням інтерфейсу. Клієнти повинні бути готові до обох випадків.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Клієнт не повинен покладатися на те, що ресурси (дисковий простір, запис каталогу тощо), раніше пов’язані з каталогом, стають негайно доступними.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_NOENT</p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_INVAL</p>
        <p class="Pr_20_Text">      NFS3ERR_EXIST</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_NAMETOOLONG</p>
        <p class="Pr_20_Text">      NFS3ERR_ROFS</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTEMPTY</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTSUPP</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також REMOVE.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        
        <p class="P3" id="section_3.3.14">3.3.14 Procedure 14: RENAME - Перейменувати файл або директорію</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      RENAME3res NFSPROC3_RENAME(RENAME3args) = 14;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct RENAME3args {</p>
        <p class="Pr_20_Text">           diropargs3   from;</p>
        <p class="Pr_20_Text">           diropargs3   to;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct RENAME3resok {</p>
        <p class="Pr_20_Text">           wcc_data     fromdir_wcc;</p>
        <p class="Pr_20_Text">           wcc_data     todir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct RENAME3resfail {</p>
        <p class="Pr_20_Text">           wcc_data     fromdir_wcc;</p>
        <p class="Pr_20_Text">           wcc_data     todir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union RENAME3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           RENAME3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           RENAME3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура RENAME перейменовує файл, ідентифікований як from.name у директорії from.dir, на to.name у дерикторії to.dir. Для клієнта операція має бути атомарною. To.dir і from.dir мають розташовуватися в одній файловій системі на тому ж сервері. RENAME3args приймає такі аргументи:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      from</p>
        <p class="Pr_20_Text">         Структура diropargs3, що ідентифікує джерело (об’єкт файлової системи, який потрібно перейменувати):</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         from.dir</p>
        <p class="Pr_20_Text">            Дескриптор файлу для директорії, запис із якї потрібно перейменувати.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         from.name</p>
        <p class="Pr_20_Text">            Ім'я запису, яке ідентифікує об'єкт, який потрібно перейменувати. Дивись "Загальні коментарі щодо імен файлів"</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      to</p>
        <p class="Pr_20_Text">        Структура diropargs3, що ідентифікує ціль (нове ім’я об’єкта):</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         to.dir</p>
        <p class="Pr_20_Text">            Дескриптор файлу для каталогу, у який потрібно перейменувати об’єкт.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         to.name</p>
        <p class="Pr_20_Text">            Нова назва об'єкта. Дивись "Загальні коментарі щодо імен файлів".</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Якщо директорія to.dir уже містить запис із назвою to.name, вихідний об’єкт має бути сумісним із цільовим: або обидва не є директоріями, або обидва є директоріями, а цільовий обʼєкт має бути порожнім. Якщо сумісні, існуюча ціль видаляється перед перейменуванням. Якщо вони несумісні, або якщо метою є директорія, яка не є порожньою, сервер має повернути помилку NFS3ERR_EXIST.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Після успішного виконання RENAME3res.status має значення NFS3_OK, а RENAME3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">        fromdir_wcc</p>
        <p class="Pr_20_Text">          Слабка узгодженність кеша даних для директорії from.dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       todir_wcc</p>
        <p class="Pr_20_Text">          Слабка узгодженність кеша даних для директорії to.dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       В іншому випадку RENAME3res.status містить інформацію про помилку, а RENAME3res.resfail містить наступне:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         fromdir_wcc</p>
        <p class="Pr_20_Text">            Слабка узгодженність кеша даних для директорії from.dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         todir_wcc</p>
        <p class="Pr_20_Text">            Слабка узгодженність кеша даних для директорії to.dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Операція RENAME для клієнта має бути атомарною. Повідомлення "to.dir та from.dir мають розташовуватися в одній файловій системі на сервері [або операція не вдасться]» означає, що поля fsid в атрибутах для директорій мають бути однакові. Якщо вони знаходяться в різних файлових системах, повертається помилка NFS3ERR_XDEV. Незважаючи на те, що операція є атомарною, статус NFS3ERR_MLINK може повертатися, якщо сервер використовував внутрішню послідовність "unlink/link/unlink.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Дескриптор файлу може стати або не може стати застарілим після перейменування. Проте розробникам серверів настійно рекомендується намагатися зберігати дескриптори файлів від застарівання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      На деяких серверах імена файлів "." і "..", є неприпустимими у from.name та to.name. Крім того, ані from.name, ані to.name не можуть бути псевдонімами для from.dir. У цих випадках ці сервери повертатимуть помилку NFS3ERR_INVAL.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Якщо «from» і «to» посилаються на той самий файл (вони можуть бути жорстким посиланнями один на одного), тоді RENAME не має виконувати жодних дій і повертати NFS3_OK.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Дивись "Загальні коментарі щодо імен файлів"</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_NOENT</p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_EXIST</p>
        <p class="Pr_20_Text">      NFS3ERR_XDEV</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_ISDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_INVAL</p>
        <p class="Pr_20_Text">      NFS3ERR_NOSPC</p>
        <p class="Pr_20_Text">      NFS3ERR_ROFS</p>
        <p class="Pr_20_Text">      NFS3ERR_MLINK</p>
        <p class="Pr_20_Text">      NFS3ERR_NAMETOOLONG</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTEMPTY</p>
        <p class="Pr_20_Text">      NFS3ERR_DQUOT</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTSUPP</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також REMOVE and LINK.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.15">3.3.15 Procedure 15: LINK - Створити посилання на обʼєкт</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      LINK3res NFSPROC3_LINK(LINK3args) = 15;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct LINK3args {</p>
        <p class="Pr_20_Text">           nfs_fh3     file;</p>
        <p class="Pr_20_Text">           diropargs3  link;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct LINK3resok {</p>
        <p class="Pr_20_Text">           post_op_attr   file_attributes;</p>
        <p class="Pr_20_Text">           wcc_data       linkdir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct LINK3resfail {</p>
        <p class="Pr_20_Text">           post_op_attr   file_attributes;</p>
        <p class="Pr_20_Text">           wcc_data       linkdir_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union LINK3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           LINK3resok    resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           LINK3resfail  resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура LINK створює жорстке посилання з file на link.name у каталозі link.dir. file та link.dir повинні знаходитися на одному сервері та файловій системі. LINK3args приймає такі аргументи:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      file</p>
        <p class="Pr_20_Text">         Дескриптор файлу для існуючого об'єкта файлової системи.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      link</p>
        <p class="Pr_20_Text">         Розташування посилання, яке буде створено:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         link.dir</p>
        <p class="Pr_20_Text">            Дескриптор файлу для директорії, у якому буде створено посилання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         link.name</p>
        <p class="Pr_20_Text">            Ім'я, яке буде пов'язано зі створеним посиланням. Дивись "Загальні коментарі щодо імен файлів".</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Після успішного повернення LINK3res.status має значення NFS3_OK, а LINK3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      file_attributes</p>
        <p class="Pr_20_Text">         Визначені файлом рost-операційні атрибути об’єкта файлової системи.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      linkdir_wcc</p>
        <p class="Pr_20_Text">         Слабка узгодженність кеша даних для директорії link.dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      В іншому випадку LINK3res.status містить повідомлення про помилку, а LINK3res.resfail містить таке:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      file_attributes</p>
        <p class="Pr_20_Text">         Визначені файлом рost-операційні атрибути об’єкта файлової системи.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      linkdir_wcc</p>
        <p class="Pr_20_Text">         Слабка узгодженність кеша даних для директорії link.dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Зміни будь-якої властивості hard-linked файлів відображаються в усіх пов’язаних файлах. Коли до файлу створюється жорстке посилання, атрибути для файлу повинні мати значення nlink, які на одиницю більше, ніж значення перед LINK.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Коментарі у розділі RENAME, стосовно об’єкта та цілі, щодо знаходження в одній файловій системі, також застосовуються і тут. Також застосовуються коментарі щодо цільової назви. Дивись "Загальні коментарі щодо імен файлів"</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_EXIST</p>
        <p class="Pr_20_Text">      NFS3ERR_XDEV</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_INVAL</p>
        <p class="Pr_20_Text">      NFS3ERR_NOSPC</p>
        <p class="Pr_20_Text">      NFS3ERR_ROFS</p>
        <p class="Pr_20_Text">      NFS3ERR_MLINK</p>
        <p class="Pr_20_Text">      NFS3ERR_NAMETOOLONG</p>
        <p class="Pr_20_Text">      NFS3ERR_DQUOT</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTSUPP</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також SYMLINK, RENAME and FSINFO.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.16">3.3.16 Procedure 16: READDIR - Читати з директорії</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      READDIR3res NFSPROC3_READDIR(READDIR3args) = 16;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct READDIR3args {</p>
        <p class="Pr_20_Text">           nfs_fh3      dir;</p>
        <p class="Pr_20_Text">           cookie3      cookie;</p>
        <p class="Pr_20_Text">           cookieverf3  cookieverf;</p>
        <p class="Pr_20_Text">           count3       count;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct entry3 {</p>
        <p class="Pr_20_Text">           fileid3      fileid;</p>
        <p class="Pr_20_Text">           filename3    name;</p>
        <p class="Pr_20_Text">           cookie3      cookie;</p>
        <p class="Pr_20_Text">           entry3       *nextentry;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct dirlist3 {</p>
        <p class="Pr_20_Text">           entry3       *entries;</p>
        <p class="Pr_20_Text">           bool         eof;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct READDIR3resok {</p>
        <p class="Pr_20_Text">           post_op_attr dir_attributes;</p>
        <p class="Pr_20_Text">           cookieverf3  cookieverf;</p>
        <p class="Pr_20_Text">           dirlist3     reply;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct READDIR3resfail {</p>
        <p class="Pr_20_Text">           post_op_attr dir_attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union READDIR3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           READDIR3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           READDIR3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура READDIR отримує змінну кількість записів послідовно з директорії та повертає назву та ідентифікатор файлу для кожного запису з інформацією, яка дозволяє клієнту запитувати додаткові записи директорії у наступному запиті READDIR. READDIR3args приймає такі аргументи:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir</p>
        <p class="Pr_20_Text">         Дескриптор файлу для директорії, який потрібно прочитати.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      cookie</p>
        <p class="Pr_20_Text">         Mає бути встановлено у 0 при першому запиті на читання директорії. У наступних запитах це має бути файл cookie, який повертає сервер. </p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      cookieverf</p>
        <p class="Pr_20_Text">         Має бути встановлено у 0 при першому запиті на читання директорії. У наступних запитах це має бути файл cookieverf, який повертає сервер. Cookiverf має відповідати тому, що повертає READDIR, у якому було отримано файл cookie.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      count</p>
        <p class="Pr_20_Text">         Максимальний розмір структури READDIR3resok у байтах. Розмір має включати всі накладні витрати XDR. Сервер може повертати менше count байтів даних.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Після успішного виконання READDIR3res.status має значення NFS3_OK, а READDIR3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir_attributes</p>
        <p class="Pr_20_Text">         Атрибути директорії, dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      cookieverf</p>
        <p class="Pr_20_Text">         веріфікатор cookie.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      reply</p>
        <p class="Pr_20_Text">         Список директорії:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         entries</p>
        <p class="Pr_20_Text">            Нуль або більше записів директорії (entry3).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         eof</p>
        <p class="Pr_20_Text">            TRUE, якщо останній запис reply.entries є останнім записом у директорії або список reply.entries порожній, а файл cookie відповідає кінцю директорії. Якщо FALSE, то можливо будуть ще записи для читання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      В іншому випадку READDIR3res.status містить повідомлення про помилку, а READDIR3res.resfail містить таке:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir_attributes</p>
        <p class="Pr_20_Text">         Атрибути директорії, dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      У протоколі NFS версії 2 кожен повернутий запис директорії включав файл cookie, який ідентифікував точку в директорії. Включивши цей файл cookie в наступний READDIR, клієнт міг відновити читання каталогу в будь-якій точці каталогу. Одна з проблем цієї схеми полягала в тому, що для сервера не було простого способу перевірити актуальність файлу cookie. Якщо два READDIR були розділені однією або декількома операціями, які певним чином змінили директорію (наприклад, змінили порядок або стисли її), можливо, другий READDIR міг пропустити записи або обробити записи більше одного разу. Якщо файл cookie більше не можна використовувати, наприклад, він вказував на середій запис у каталозі, то сервер мав би округлити файл cookie до файлу cookie попереднього запису, або округлити його до файлу cookie наступного запису в директорії. Будь-який спосіб може призвести до неправильних результатів, і клієнт не буде знати про існування будь-якої проблеми.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      У протоколі NFS версії 3 кожен запит READDIR включає файл cookie та засіб перевірки файлів cookie. Для першого виклику для обох встановлено значення 0. Відповідь включає новий веріфікатор файлів cookie з файлом cookie для кожного запису. Для наступних READDIR клієнт повинен надати як файл cookie, так і відповідний веріфікатор файлів cookie. Якщо сервер виявить, що файл cookie більше не дійсний, сервер відхилить запит READDIR зі статусом NFS3ERR_BAD_COOKIE. Клієнт повинен бути обережним, щоб уникнути утримання записів файлів cookie в директорії під час операцій, які змінюють вміст директорії, наприклад REMOVE та CREATE.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Для веріфікації cookie, сервер може використовувати час модифікації файла директорії. Однак це може бути занадто обмеженим. Кращим підходом було б записати час останньої модифікації директорії, яка змінила її організацію таким чином, що унеможливила надійну інтерпретацію файлу cookie. Сервери, у яких файли cookie директорії завжди дійсні, можуть завжди використовувати нуль як перевірку.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Сервер може повернути менше байтів XDR-кодованих записів. Лічильник, указаний клієнтом у запиті, має бути більшим або дорівнювати FSINFO dtpref.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Оскільки клієнти UNIX надають особливе значення нульовому значенню fileid, клієнтам UNIX слід бути обережними, щоб співставляти нульові значення fileid з деякими іншими значеннями. Серверам слід намагатися уникати надсилання нульового fileid.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ERRORS</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_BAD_COOKIE</p>
        <p class="Pr_20_Text">      NFS3ERR_TOOSMALL</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також READDIRPLUS and FSINFO.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
                
        
        <p class="P3" id="section_3.3.17">3.3.17 Procedure 17: READDIRPLUS - Розширене читання директорії</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      READDIRPLUS3res NFSPROC3_READDIRPLUS(READDIRPLUS3args) = 17;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct READDIRPLUS3args {</p>
        <p class="Pr_20_Text">           nfs_fh3      dir;</p>
        <p class="Pr_20_Text">           cookie3      cookie;</p>
        <p class="Pr_20_Text">           cookieverf3  cookieverf;</p>
        <p class="Pr_20_Text">           count3       dircount;</p>
        <p class="Pr_20_Text">           count3       maxcount;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct entryplus3 {</p>
        <p class="Pr_20_Text">           fileid3      fileid;</p>
        <p class="Pr_20_Text">           filename3    name;</p>
        <p class="Pr_20_Text">           cookie3      cookie;</p>
        <p class="Pr_20_Text">           post_op_attr name_attributes;</p>
        <p class="Pr_20_Text">           post_op_fh3  name_handle;</p>
        <p class="Pr_20_Text">           entryplus3   *nextentry;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct dirlistplus3 {</p>
        <p class="Pr_20_Text">           entryplus3   *entries;</p>
        <p class="Pr_20_Text">           bool         eof;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct READDIRPLUS3resok {</p>
        <p class="Pr_20_Text">           post_op_attr dir_attributes;</p>
        <p class="Pr_20_Text">           cookieverf3              cookieverf;</p>
        <p class="Pr_20_Text">           dirlistplus3 reply;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct READDIRPLUS3resfail {</p>
        <p class="Pr_20_Text">           post_op_attr dir_attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union READDIRPLUS3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           READDIRPLUS3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           READDIRPLUS3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>        
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура READDIRPLUS отримує змінну кількість записів із директорії файлової системи та повертає повну інформацію про кожен запис разом із інформацією, яка дозволяє клієнту запитувати додаткові записи директорії в наступному READDIRPLUS. READDIRPLUS відрізняється від READDIR лише обсягом інформації, що повертається для кожного запису. У READDIR кожен запис повертає назву файлу (filename) та ідентифікатор файлу (fileid). У READDIRPLUS кожен запис повертає назву, ідентифікатор файлу, атрибути (включно з fileid) та дескриптор файлу. Під час входу аргументи в READDIRPLUS3args є такими:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      dir</p>
        <p class="Pr_20_Text">         Файловий дискриптор директорії, яку потрібно прочитати.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      cookies</p>
        <p class="Pr_20_Text">         Має бути встановлено у 0 під час першого запиту на читання директорії. У наступних запитах це має бути файл cookie, який повертає сервер.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       cookieverf</p>
        <p class="Pr_20_Text">         Має бути встановлено у 0 під час першого запиту на читання каталогу. У наступних запитах це має бути файл cookieverf, який повертає сервер. Cookiverf має відповідати тому, що повертається викликом READDIRPLUS, у якому було отримано файл cookie.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dircount</p>
        <p class="Pr_20_Text">         Максимальна кількість байтів інформації директорії, що повертається. Це число не повинно включати розмір частин результату з атрибутами та описом файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       maxcount</p>
        <p class="Pr_20_Text">          Максимальний розмір структури READDIRPLUS3resok у байтах. Розмір має включати всі накладні витрати XDR.</p>
        <p class="Pr_20_Text">          Сервер може повертати менше ніж maxcount байт даних.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       Після успішного виконання READDIRPLUS3res.status має значення NFS3_OK, а READDIRPLUS3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_attributes</p>
        <p class="Pr_20_Text">          Атрибути директорії, dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       cookieverf</p>
        <p class="Pr_20_Text">          Перевірка файлів cookie.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       reply</p>
        <p class="Pr_20_Text">          Список директорії:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">          entries</p>
        <p class="Pr_20_Text">            Нуль або більше записів директорії (entryplus3).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">          eof</p>
        <p class="Pr_20_Text">            TRUE, якщо останній запис reply.entries є останнім записом у директорії або список reply.entries порожній, а файл cookie відповідає кінцю директорії. Якщо FALSE, то можливо будуть ще записи для читання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      В іншому випадку READDIRPLUS3res.status містить повідомлення про помилку, а READDIRPLUS3res.resfail містить таке:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       dir_attributes</p>
        <p class="Pr_20_Text">          Атрибути директорії, dir.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Проблеми, які слід розуміти для цієї процедури, включають збільшення активності очищення кешу на клієнті (оскільки нові дескриптори файлів повертаються з іменами, які вводяться в кеші) і накладні витрати через мережевий зв’язок порівняно з очікуваним подальшим очищенням LOOKUP. Вважається, що ця процедура може покращити продуктивність для перегляду директорій, де атрибути завжди потрібні, як в операційній системі Apple Macintosh та для MS-DOS.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Поля dircount і maxcount включені для оптимізації. Розглянемо виклик READDIRPLUS у реалізації операційної системи UNIX для 1048 байт; відповідь не містить багато записів через накладні витрати через атрибути та файлові дискриптори. Альтернативою є виконання виклику READDIRPLUS для 8192 байтів, а потім використання лише перших 1048 байтів інформації директорії. Однак сервер не знає, що все, що потрібно, це 1048 байт інформації директорії (як повертає READDIR). Він бачить запит 8192 байтів і видає VOP_READDIR для 8192 байтів. Потім він проходить усі ці записи директорії, отримуючи атрибути та дескриптори файлів для кожного запису. Коли він кодує результат, сервер кодує лише до тих пір, поки не отримає 8192 байти результатів, які включають атрибути та файлові дискриптори. Таким чином, він зробив більший VOP_READDIR і отримав набагато більше атрибутів, ніж було потрібно. Співвідношення розміру запису директорії до розміру атрибутів плюс розміру файлового дискриптора зазвичай становить принаймні 8 до 1. Сервер виконав набагато більше роботи, ніж потрібно.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Рішення цієї проблеми полягає в тому, щоб клієнт надав серверу два підрахунки. По-перше, це кількість байтів інформації директорії, яка дійсно потрібна клієнту, dircount. Друге — це максимальна кількість байтів у результаті, включаючи атрибути та файлові дискриптори, maxcount. Таким чином, сервер видасть VOP_READDIR лише для кількості байтів, яку клієнт дійсно хоче отримати, а не для завищеного числа. Це повинно допомогти зменшити розмір запитів VOP_READDIR на сервері, таким чином зменшивши обсяг роботи, що виконується, і зменшити кількість VOP_LOOKUP, VOP_GETATTR та інших викликів, які виконує сервер для створення атрибутів і файлових дескрипторів.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_ACCES</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTDIR</p>
        <p class="Pr_20_Text">      NFS3ERR_BAD_COOKIE</p>
        <p class="Pr_20_Text">      NFS3ERR_TOOSMALL</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_NOTSUPP</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також READDIR.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
                
        
        <p class="P3" id="section_3.3.18">3.3.18 Procedure 18: FSSTAT - Отримати динамічну інформацію про файлову систему</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   FSSTAT3res NFSPROC3_FSSTAT(FSSTAT3args) = 18;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct FSSTAT3args {</p>
        <p class="Pr_20_Text">           nfs_fh3   fsroot;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct FSSTAT3resok {</p>
        <p class="Pr_20_Text">           post_op_attr obj_attributes;</p>
        <p class="Pr_20_Text">           size3        tbytes;</p>
        <p class="Pr_20_Text">           size3        fbytes;</p>
        <p class="Pr_20_Text">           size3        abytes;</p>
        <p class="Pr_20_Text">           size3        tfiles;</p>
        <p class="Pr_20_Text">           size3        ffiles;</p>
        <p class="Pr_20_Text">           size3        afiles;</p>
        <p class="Pr_20_Text">           uint32       invarsec;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct FSSTAT3resfail {</p>
        <p class="Pr_20_Text">           post_op_attr obj_attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union FSSTAT3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           FSSTAT3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           FSSTAT3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура FSSTAT отримує мінливу інформацію про стан файлової системи.  FSSTAT3args приймає такі аргументи:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      fsroot</p>
        <p class="Pr_20_Text">         Дескриптор файлу, що ідентифікує об'єкт у файловій системі. Зазвичай це дескриптор файлу для точки монтування файлової системи, отриманий від служби MOUNT на сервері.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Після успішного повернення FSSTAT3res.status має значення NFS3_OK, а FSSTAT3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      obj_attributes</p>
        <p class="Pr_20_Text">          Атрибути об'єкта файлової системи, вказані в fsroot.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      tbytes</p>
        <p class="Pr_20_Text">         Загальний розмір файлової системи в байтах.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      fbytes</p>
        <p class="Pr_20_Text">         Кількість вільного місця у файловій системі в байтах.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      abytes</p>
        <p class="Pr_20_Text">         Кількість вільного місця в байтах, доступного користувачеві, визначеному інформацією автентифікації в RPC. (Це є простір, зарезервований файловою системою; abytes не відображає жодної системи квот, реалізованої сервером.)</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      tfiles</p>
        <p class="Pr_20_Text">         Загальна кількість файлових слотів у файловій системі. (На сервері UNIX це часто відповідає кількості налаштованих inode.)</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      ffiles</p>
        <p class="Pr_20_Text">         Кількість вільних слотів для файлів у файловій системі.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      afiles</p>
        <p class="Pr_20_Text">         Кількість вільних слотів для файлів, які доступні для користувача, відповідно до інформації автентифікації в RPC. (відображає слоти, зарезервовані файловою системою; afiles не відображає жодної системи квот, реалізованої сервером.)</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      invarsec</p>
        <p class="Pr_20_Text">         Показник мінливості файлової системи: це кількість секунд, протягом яких очікується, що файлова система не буде змінена. Для мінливої файлової системи, яка часто оновлюється, це буде 0. Для незмінної файлової системи, такої як CD-ROM, це буде найбільше ціле число без знаку. Для файлових систем, які рідко змінюються, наприклад, таких, що містять локальні виконувані програми та онлайн-документацію, може використовуватися значення, що відповідає кільком годинам або дням. Клієнт може використовувати це як підказку для налаштування керування кеш-пам’яттю. Однак зауважте, що цей показник вважається динамічним і може змінитися в будь-який час.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   В іншому випадку FSSTAT3res.status містить повідомлення про помилку, а FSSTAT3res.resfail містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      obj_attributes</p>
        <p class="Pr_20_Text">          Атрибути об'єкта файлової системи, вказані в fsroot.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Не всі реалізації можуть підтримувати весь перелік атрибутів. Очікується, що сервери докладуть усіх зусиль для підтримки всіх атрибутів.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ПОМИЛКИ </p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_IO</p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також FSINFO.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.19">3.3.19 Procedure 19: FSINFO - Отримати статичну інформацію про файлову систему</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      FSINFO3res NFSPROC3_FSINFO(FSINFO3args) = 19;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      const FSF3_LINK        = 0x0001;</p>
        <p class="Pr_20_Text">      const FSF3_SYMLINK     = 0x0002;</p>
        <p class="Pr_20_Text">      const FSF3_HOMOGENEOUS = 0x0008;</p>
        <p class="Pr_20_Text">      const FSF3_CANSETTIME  = 0x0010;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct FSINFOargs {</p>
        <p class="Pr_20_Text">           nfs_fh3   fsroot;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct FSINFO3resok {</p>
        <p class="Pr_20_Text">           post_op_attr obj_attributes;</p>
        <p class="Pr_20_Text">           uint32       rtmax;</p>
        <p class="Pr_20_Text">           uint32       rtpref;</p>
        <p class="Pr_20_Text">           uint32       rtmult;</p>
        <p class="Pr_20_Text">           uint32       wtmax;</p>
        <p class="Pr_20_Text">           uint32       wtpref;</p>
        <p class="Pr_20_Text">           uint32       wtmult;</p>
        <p class="Pr_20_Text">           uint32       dtpref;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">     size3        maxfilesize;</p>
        <p class="Pr_20_Text">           nfstime3     time_delta;</p>
        <p class="Pr_20_Text">           uint32       properties;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct FSINFO3resfail {</p>
        <p class="Pr_20_Text">           post_op_attr obj_attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union FSINFO3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           FSINFO3resok   resok;</p>
        <p class="Pr_20_Text">                 default:</p>
        <p class="Pr_20_Text">           FSINFO3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура FSINFO отримує енергонезалежну інформацію про стан файлової системи та загальну інформацію про реалізацію сервера протоколу NFS версії 3. FSINFO3args приймає такі аргументи:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      fsroot</p>
        <p class="Pr_20_Text">         Дескриптор файлу, що ідентифікує файловий об'єкт. Звичайне використання полягає в наданні файлового дискриптора точки монтування файлової системи, яка попередньо була отримана від служби MOUNT на сервері.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Після успішного виконання FSINFO3res.status має значення NFS3_OK, а FSINFO3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         obj_attributes</p>
        <p class="Pr_20_Text">            Атрибути об'єкта файлової системи, вказані в fsroot.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         rtmax</p>
        <p class="Pr_20_Text">            Максимальний розмір у байтах запиту READ, який підтримується сервером. Будь-яке READ із числом, більшим за rtmax, призведе до короткого читання rtmax байтів або менше.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         rtpref</p>
        <p class="Pr_20_Text">            Бажаний розмір запиту READ. Він має бути таким самим, як і rtmax, якщо немає явної переваги в продуктивності чи ефективності.  </p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         rtmult</p>
        <p class="Pr_20_Text">            Пропонований кратний розмір запиту READ.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         wtmax</p>
        <p class="Pr_20_Text">            Максимальний розмір запиту WRITE, який підтримується сервером. Загалом, клієнт обмежений wtmax, оскільки немає гарантії, що сервер зможе обробити більший запис. Будь-яка WRITE з кількістю, більшою за wtmax, призведе до короткого запису максимум wtmax байтів.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         wtpref</p>
        <p class="Pr_20_Text">            Бажаний розмір запиту WRITE. Він має бути таким самим, як wtmax, якщо немає явної переваги в продуктивності чи ефективності.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         wtmult</p>
        <p class="Pr_20_Text">            Пропонований кратний розмір запиту WRITE.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         dtpref</p>
        <p class="Pr_20_Text">            Бажаний розмір запиту READDIR.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         maxfilesize</p>
        <p class="Pr_20_Text">            Максимальний розмір файлу у файловій системі.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         time_delta</p>
        <p class="Pr_20_Text">            Деталізація часу сервера. Встановлюючи час файлу за допомогою SETATTR, сервер гарантує збереження часу лише з цією точністю. Якщо це значення {0, 1}, сервер може підтримувати час у наносекундах, {0, 1000000} позначає точність у мілісекундах, а {1, 0} вказує, що час точний лише з точністю до найближчої секунди.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         properties</p>
        <p class="Pr_20_Text">            Бітова маска властивостей файлової системи. Визначаються такі значення:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">            FSF_LINK</p>
        <p class="Pr_20_Text">               Якщо цей біт дорівнює 1 (TRUE), файлова система підтримує жорсткі посилання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">            FSF_SYMLINK</p>
        <p class="Pr_20_Text">               Якщо цей біт дорівнює 1 (TRUE), файлова система підтримує символічні посилання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">            FSF3_HOMOGENEOUS</p>
        <p class="Pr_20_Text">               Якщо цей біт дорівнює 1 (TRUE), інформація, яку повертає PATHCONF, є ідентичною для кожного файлу та каталогу у файловій системі. Якщо він дорівнює 0 (FALSE), клієнт повинен отримати інформацію PATHCONF для кожного файлу та каталогу відповідно до вимог.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">            FSF_CANSETTIME</p>
        <p class="Pr_20_Text">               Якщо цей біт дорівнює 1 (TRUE), сервер за запитом встановить час для файлу через SETATTR (з точністю, зазначеною time_delta). Якщо значення 0 (FALSE), сервер не може встановити час відповідно до запиту.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         В іншому випадку FSINFO3res.status містить повідомлення про помилку, а FSINFO3res.resfail містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">         attributes</p>
        <p class="Pr_20_Text">            Атрибути об'єкта файлової системи, які вказані в fsroot.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Не всі реалізації можуть підтримувати весь список атрибутів. Очікується, що сервер докладе всіх зусиль для підтримки всіх атрибутів.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Очікується, що наданий файловий дескриптор буде файловим дескриптором кореня файлової системи, що повертається операцією MOUNT. Оскільки монтування може відбуватися будь-де в експортованому дереві, сервер має очікувати запити FSINFO, що вказують файлові дескриптори у експортованій файловій системі. Сервер може експортувати різні типи файлових систем із різними атрибутами, що повертаються викликом FSINFO. Клієнт повинен отримувати інформацію FSINFO для кожного завершеного монтування. Хоча сервер може повертати різну інформацію FSINFO для різних файлів у файловій системі, немає такої вимоги, щоб клієнт отримував інформацію FSINFO, окрім файлового дескриптора, повернутого під час монтування.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Поле maxfilesize визначає, чи конкретна файлова система сервера використовує 32-бітні розміри та зсуви, чи 64-бітні розміри та зсуви. Це може вплинути на роботу клієнта.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Бажані розміри для запитів номінально прив’язані до експортованої файлової системи, змонтованої клієнтом. Проблема, яку можна вирішити, полягає в тому, що розмір передачі для запиту протоколу NFS версії 3 залежить не лише від характеристик файлової системи, а й від характеристик мережевого інтерфейсу, зокрема від максимальної одиниці передачі (MTU). Серверна реалізація може повідомляти про різні розміри передачі (для fields, rtmax, rtpref, wtmax, wtpref та dtpref) залежно від інтерфейсу, на якому отримано запит FSINFO. Це питання реалізації.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      NFS3ERR_STALE</p>
        <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також  READLINK, WRITE, READDIR, FSSTAT and PATHCONF.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.20">3.3.20 Procedure 20: PATHCONF - Отримати інформацію POSIX </p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   PATHCONF3res NFSPROC3_PATHCONF(PATHCONF3args) = 20;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct PATHCONF3args {</p>
        <p class="Pr_20_Text">           nfs_fh3   object;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct PATHCONF3resok {</p>
        <p class="Pr_20_Text">           post_op_attr obj_attributes;</p>
        <p class="Pr_20_Text">           uint32       linkmax;</p>
        <p class="Pr_20_Text">           uint32       name_max;</p>
        <p class="Pr_20_Text">           bool         no_trunc;</p>
        <p class="Pr_20_Text">           bool         chown_restricted;</p>
        <p class="Pr_20_Text">           bool         case_insensitive;</p>
        <p class="Pr_20_Text">           bool         case_preserving;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct PATHCONF3resfail {</p>
        <p class="Pr_20_Text">           post_op_attr obj_attributes;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union PATHCONF3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           PATHCONF3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           PATHCONF3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура PATHCONF отримує інформацію pathconf для файлу або каталогу. Якщо біт FSF_HOMOGENEOUS установлено у FSFINFO3resok.properties, інформація pathconf буде однаковою для всіх файлів і каталогів у експортованій файловій системі, у якій цей файл або каталог знаходиться. PATHCONF3args приймає такі аргументи:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      object</p>
        <p class="Pr_20_Text">         Дескриптор файлу для об'єкта файлової системи.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Після успішного повернення PATHCONF3res.status має значення NFS3_OK a PATHCONF3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      obj_attributes</p>
        <p class="Pr_20_Text">         Атрибути об'єкта, визначені об'єктом.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      linkmax</p>
        <p class="Pr_20_Text">         Максимальна кількість жорстких посилань на об'єкт.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      name_макс</p>
        <p class="Pr_20_Text">         Максимальна довжина компонента filename.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      no_trunc</p>
        <p class="Pr_20_Text">         Якщо TRUE, сервер відхилить будь-який запит, який містить ім’я, яке довше за name_max, із помилкою NFS3ERR_NAMETOOLONG. Якщо FALSE, будь-яке ім’я довжиною понад name_max байтів без повідомлень буде скорочено до name_max байтів.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      chown_restricted</p>
        <p class="Pr_20_Text">         Якщо TRUE, сервер відхилить будь-який запит на зміну власника або групи, пов’язаної з файлом, якщо визиваючий не є привілейованим користувачем. (Uid 0.)</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      case_insensitive</p>
        <p class="Pr_20_Text">         Якщо TRUE, файлова система сервера не розрізняє регістр під час інтерпретації імен файлів.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      case_preserving</p>
        <p class="Pr_20_Text">         Якщо TRUE, файлова система сервера зберігатиме регістр імені під час операцій CREATE, MKDIR, MKNOD, SYMLINK, RENAME або LINK.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      В іншому випадку PATHCONF3res.status містить повідомлення про помилку, а PATHCONF3res.resfail містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      obj_
            attributes</p>
        <p class="Pr_20_Text">          Атрибути об'єкта, визначені об'єктом.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      У деяких реалізаціях протоколу NFS версії 2 інформація про pathconf отримувалася під час монтування через протокол MOUNT. Належним місцем для отримання pathconf є, як тут, у самому протоколі NFS версії 3.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ПОМИЛКИ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   NFS3ERR_STALE</p>
        <p class="Pr_20_Text">   NFS3ERR_BADHANDLE</p>
        <p class="Pr_20_Text">   NFS3ERR_SERVERFAULT</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Дивись також LOOKUP, CREATE, MKDIR, SYMLINK, MKNOD, RENAME, LINK, FSINFO.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
        
        
        <p class="P3" id="section_3.3.21">3.3.21 Procedure 21: COMMIT - Зафіксувати дані з кешу у стабільне сховище</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   СИНОПСИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      COMMIT3res NFSPROC3_COMMIT(COMMIT3args) = 21;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct COMMIT3args {</p>
        <p class="Pr_20_Text">           nfs_fh3    file;</p>
        <p class="Pr_20_Text">           offset3    offset;</p>
        <p class="Pr_20_Text">           count3     count;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct COMMIT3resok {</p>
        <p class="Pr_20_Text">           wcc_data   file_wcc;</p>
        <p class="Pr_20_Text">           writeverf3 verf;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct COMMIT3resfail {</p>
        <p class="Pr_20_Text">           wcc_data   file_wcc;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      union COMMIT3res switch (nfsstat3 status) {</p>
        <p class="Pr_20_Text">      case NFS3_OK:</p>
        <p class="Pr_20_Text">           COMMIT3resok   resok;</p>
        <p class="Pr_20_Text">      default:</p>
        <p class="Pr_20_Text">           COMMIT3resfail resfail;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   ОПИС</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура COMMIT скидає дані до стабільного сховища, які були раніше записані за допомогою виклику процедури WRITE з полем stable, встановленим у UNSTABLE. COMMIT3args приймає такі аргументи:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      file</p>
        <p class="Pr_20_Text">         Файловий дескриптор файла, у який потрібно скинути (зафіксувати) дані. Це ідентифікує об’єкт файлової системи типу NF3REG.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      offset</p>
        <p class="Pr_20_Text">         Позиція у файлі, з якої має початися скидання. Offset 0 означає скидання даних, починаючи з початку файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      count</p>
        <p class="Pr_20_Text">         Кількість байтів даних для скидання. Якщо count дорівнює 0, виконується скидання від offset до кінця файлу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Після успішного виконання COMMIT3res.status має значення NFS3_OK, а COMMIT3res.resok містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      file_wcc</p>
        <p class="Pr_20_Text">         Слабка узгодженність кеша даних для файлу. Для клієнта, якому потрібні лише атрибути файлу після операції, їх можна знайти у file_wcc.after.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      verf</p>
        <p class="Pr_20_Text">         Це файл cookie, за допомогою якого клієнт може визначити, чи перезавантажився сервер між викликом WRITE і наступним викликом COMMIT. Цей файл cookie має бути узгодженим протягом одного сеансу завантаження та має бути унікальним між екземплярами сервера протоколу NFS версії 3, де незафіксовані дані можуть бути втрачені.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      В іншому випадку COMMIT3res.status містить повідомлення про помилку, а COMMIT3res.resfail містить:</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      file_wcc</p>
        <p class="Pr_20_Text">        Слабка узгодженність кеша даних для файлу. Для клієнта, якому потрібні лише атрибути файлу після запису, їх можна знайти у file_wcc.after. Незважаючи на невдачу COMMIT, повертає повний wcc_data, щоб дозволити клієнту визначити, чи змінився файл на сервері між викликами WRITE і COMMIT.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Процедура COMMIT за роботою та семантикою подібна до системного виклику POSIX fsync(2), який синхронізує стан файлу з диском, тобто скидає дані та метадані файлу на диск. COMMIT виконує ту саму операцію для клієнта, скидаючи будь-які несинхронізовані дані та метадані на сервері на диск сервера для вказаного файлу. Подібно до fsync(2), може бути, що є деякі змінені дані для синхронізації або їх немає. Можливо, дані були синхронізовані за допомогою звичайної періодичної синхронізації буфера сервера. COMMIT завжди повертатиме NFS3_OK, якщо не сталася неочікувана помилка.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      COMMIT відрізняється від fsync(2) тим, що клієнт може скинути діапазон файлу (швидше за все, викликане схемою відновлення буфера на клієнті до того, як файл буде повністю записаний).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Серверна реалізація COMMIT досить проста. Якщо сервер отримує повний запит на COMMIT файлу, який починається зі зміщення 0 і лічильника 0, він повинен виконати еквівалент fsync() для файлу. В іншому випадку він повинен зробити так, щоб кешовані дані в діапазоні, визначеному offset і count, скидалися до стабільного сховища. В обох випадках будь-які метадані, пов’язані з файлом, потрібно скинути до стабільного сховища до повернення. Це не помилка, якщо на сервері немає чого скидати. Це означає, що дані та метадані, які потрібно було скинути, уже скинуто або втрачено під час останнього збою сервера.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Клієнтська реалізація COMMIT трохи складніша. Є дві причини для того, щоб затримати скид клієнтського буферу до стабільного сховища. По-перше, клієнт хоче повторно використовувати буфер. У цьому випадку offset і count буфера надсилаються на сервер у запиті COMMIT. Потім сервер очищає будь-які кешовані дані на основі offset та count, а також очищає будь-які метадані, пов’язані з файлом. Потім він повертає статус скидання та верифікатора verf. Іншою причиною для створення клієнтом COMMIT є повне скидання файлу, наприклад, після закриття. У цьому випадку клієнт збирає всі буфери для цього файлу, які містять незафіксовані дані, виконує операцію COMMIT з offset 0 і count 0, а потім звільняє всі ці буфери. Будь-які інші брудні буфери будуть надіслані на сервер у звичайному стилі.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Ця реалізація вимагатиме деяких змін у буферному кеші на клієнті. Після запису буфера зі stable UNSTABLE клієнтська система повинна розглядати його як брудний, доки він не буде скинутий за допомогою операції COMMIT або записаний за допомогою операції WRITE зі stable значенням FILE_SYNC або DATA_SYNC. Це робиться, щоб запобігти звільненню та повторному використанню буфера до того, як дані можна буде скинути в стабільне сховище на сервері.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      Коли відповідь надходить від операції WRITE або COMMIT, яка містить неочікуваний verf, клієнту потрібно буде повторно передати всі буфери, що містять незакріплені кешовані дані на сервер. Як це зробити, залежить від реалізації. Якщо цікавить лише один буфер, то його, ймовірно, слід надіслати назад у запиті WRITE з відповідним прапорцем стабільності. Якщо їх більше одного, можливо, варто повторно передати всі буфери в запитах WRITE зі stable значенням UNSTABLE, а потім повторно передати операцію COMMIT, щоб скинути всі дані на сервері в стабільне сховище. Час виконання цих повторних передач залишається на розсуд виконавця.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Наведений вище опис стосується систем на основі кеша сторінок, а також систем на основі кешу буфера. У цих системах замість буферного кешу потрібно буде змінити систему віртуальної пам’яті.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ПОМИЛКИ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      NFS3ERR_IO</p>
            <p class="Pr_20_Text">      NFS3ERR_STALE</p>
            <p class="Pr_20_Text">      NFS3ERR_BADHANDLE</p>
            <p class="Pr_20_Text">      NFS3ERR_SERVERFAULT</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Дивись додаткові коментарі до WRITE.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            <hr>
            <p class="Pr_20_Text"> </p>
            
            
            
            
            
            
            
            <p class="P2" id="section_4">4. Проблеми впровадження</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Протокол NFS версії 3 був розроблений, щоб дозволити різним операційним системам обмінюватися файлами. Однак, оскільки вона була розроблена в середовищі UNIX, багато операцій мають семантику, подібну до операцій файлової системи UNIX. У цьому розділі обговорюються деякі загальні деталі реалізації та семантичні проблеми. Описи процедур містять коментарі щодо реалізації, специфічні для цієї процедури.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Було написано ряд документів, в яких описуються проблеми, що виникають під час побудови реалізації протоколу NFS версії 2. Найкращою оглядовою статтею залишається [Сандберг]. [Israel], [Macklem] і [Pawlowski] описують інші реалізації. [X/OpenNFS] надає повний опис протоколу NFS версії 2 і допоміжних протоколів, а також обговорення питань впровадження, процедур і семантики помилок. Багато проблем, які виникають під час побудови реалізації протоколу NFS версії 2, виникнуть під час побудови реалізації протоколу NFS версії 3.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            <p class="P3" id="section_4.1">4.1 Підтримка кількох версій</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Протокол RPC забезпечує явну підтримку керування версіями служби. Клієнтська та серверна реалізації протоколу NFS версії 3 повинні підтримувати обидві версії для повної зворотної сумісності, коли це можливо. Типовою поведінкою протоколу зв’язування RPC є зв’язування клієнта та сервера з використанням найвищого номера версії, яку вони обидва підтримують. Реалізації клієнта або сервера, які не можуть легко підтримувати обидві версії (наприклад, через обмеження пам’яті), повинні будуть обирати, яку версію підтримувати. Протокол NFS версії 2 був би безпечним вибором, оскільки повнофункціональні клієнти та сервери повинні підтримувати обидві версії. Однак цей вибір потрібно зробити з урахуванням усіх вимог.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
                        
            <p class="P3" id="section_4.2">4.2 Взаємодія сервер/клієнт</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Протокол NFS версії 3 розроблений, щоб дозволити серверам бути максимально простими та загальними. Іноді простота сервера може бути проблемою, якщо клієнт реалізує складну семантику файлової системи.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Наприклад, деякі операційні системи дозволяють видаляти відкриті файли. Процес може відкрити файл і, поки файл відкритий, видалити його з каталогу. Файл можна читати та записувати, доки процес утримує його відкритим, навіть якщо файл не має імені у файловій системі. Неможливо для сервера без стану реалізувати цю семантику. Клієнт може виконувати деякі трюки, наприклад перейменовувати файл під час видалення (на приховане ім’я) і лише фізично видаляти його під час закриття. Протокол NFS версії 3 забезпечує достатню функціональність для реалізації більшості семантик файлової системи на клієнті. </p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Кожен клієнт протоколу NFS версії 3 потенційно також може бути сервером, а віддалені та локальні змонтовані файлові системи можна вільно змішувати. Це призводить до деяких проблем, коли клієнт переміщається по дереву каталогів віддаленої файлової системи та досягає точки монтування на сервері для іншої віддаленої файлової системи. Щоб дозволити серверу слідувати другому віддаленому монтуванню, знадобиться виявлення циклу, пошук сервера та повторна перевірка користувача. Натомість реалізація протоколу NFS версії 2 і NFS версії 3 зазвичай не дозволяє клієнтам перетинати точку монтування сервера. Коли клієнт виконує LOOKUP у каталозі, у якому сервер змонтував файлову систему, клієнт бачить базовий каталог замість змонтованого каталогу.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Наприклад, сервер має файлову систему під назвою /usr і монтує іншу файлову систему до /usr/src. Якщо клієнт монтує /usr, він не бачить змонтовану версію /usr/src. Клієнт може виконувати віддалене монтування, яке відповідає точкам монтування сервера, щоб підтримувати перегляд сервера. У цьому прикладі клієнт також має змонтувати /usr/src на додаток до /usr, навіть якщо вони з того самого сервера.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            <p class="P3" id="section_4.3">4.3 Інтерпретація імені шляху</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Існує кілька ускладнень правила, згідно з яким імена шляхів завжди аналізуються на клієнті. Наприклад, символічні посилання можуть мати різні інтерпретації на різних клієнтах. Ця специфікація немає відповіді на цю проблему.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Іншою поширеною проблемою для не-UNIX реалізацій є спеціальна інтерпретація імені шляху, "..", що означає батьківський каталог даного каталогу. Майбутня версія протоколу може використовувати явний прапорець для вказівки батьківського протоколу замість цього - однак це не є проблемою, оскільки існує багато робочих реалізацій, відмінних від UNIX.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
                        
            
            <p class="P3" id="section_4.4">4.4 Проблеми з дозволом</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Протокол NFS версії 3, строго кажучи, не визначає перевірку дозволів, що використовується серверами. Однак очікується, що сервер виконуватиме звичайну перевірку дозволів операційної системи, використовуючи автентифікацію в стилі AUTH_UNIX як основу свого механізму захисту або іншу більш сильну форму автентифікації, таку як AUTH_DES або AUTH_KERB. За допомогою автентифікації AUTH_UNIX сервер отримує ефективний uid клієнта, ефективний gid і групи під час кожного виклику та використовує їх для перевірки дозволу. Це так звані облікові дані UNIX. AUTH_DES і AUTH_KERB використовують мережеве ім’я або netname як основу для ідентифікації (з якої сервер UNIX отримує необхідні стандартні облікові дані UNIX). Є проблеми з цим методом, які були вирішені.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Використання uid і gid означає, що клієнт і сервер мають спільний список uid. Кожна пара серверів і клієнтів повинна мати однакове перетворення від user до uid і від group до gid. Оскільки кожен клієнт також може бути сервером, це, як правило, означає, що вся мережа спільно використовує той самий простір uid/gid. Якщо це не так, тоді сервер, як правило, виконує певне користувальницьке перетворення облікових даних з одного домену автентифікації в інший. Обговорення методів керування спільним простором користувача або забезпечення механізмів відображення ідентифікатора користувача виходить за рамки цієї специфікації.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Інша проблема виникає через звичайну операцію відкриття зі збереженням стану (stateful open). Більшість операційних систем перевіряють дозвіл під час відкриття, а потім перевіряють, чи файл відкрито під час кожного запиту на читання та запис. На серверах без збереження стану сервер не може виявити, що файл відкритий, і повинен виконувати перевірку дозволу під час кожного виклику читання та запису. Семантика клієнта UNIX для перевірки дозволів доступу під час відкриття може бути виконана за допомогою виклику процедури ACCESS у редакції, що дозволяє клієнту явно перевіряти дозволи доступу, не вдаючись до операції. У локальній файловій системі користувач може відкрити файл, а потім змінити дозволи, щоб нікому не було дозволено торкатися його, але все одно зможе писати у файл, оскільки він відкритий. У віддаленій файловій системі, навпаки, запис не відбудеться. Щоб вирішити цю проблему, алгоритм перевірки дозволів сервера повинен дозволяти власнику файлу отримати до нього доступ незалежно від налаштування дозволу. Це необхідно для практичної реалізації сервера протоколу NFS версії 3, але це відхиляється від правильної семантики локальної файлової системи. Однак, це не повинно впливати на результат повернення дозволів доступу, які повертає процедура ACCESS.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Подібна проблема має відношення до сторінок (pagein) у програмі, яка виконується через мережу. Операційна система, як правило, перевіряє дозвіл на виконання перед відкриттям файлу для підкачки сторінок, а потім читає блоки з відкритого файлу. У локальній файловій системі UNIX виконуваний файл не потребує дозволу на читання для виконання (pagein). Сервер протоколу NFS версії 3 не може відрізнити звичайне читання файлу (де біт дозволу на читання є значущим) і сторінку на вимогу читання (де сервер має дозволити доступ до виконуваного файлу, якщо для цього користувача встановлено біт виконання або груповий, або публічний). Щоб це працювало, сервер дозволяє читати файли, якщо uid, наданий у виклику, має дозвіл на виконання або читання файлу через право власності, членство в групі або публічний доступ. Знову ж таки, це відхиляється від правильної семантики локальної файлової системи.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   У більшості операційних систем окремий користувач (в UNIX uid 0) має доступ до всіх файлів, незалежно від того, який дозвіл і право власності він має. Цей дозвіл суперкористувача може бути заборонений на сервері, оскільки кожен, хто може стати суперкористувачем на своєму клієнті, може отримати доступ до всіх віддалених файлів. Сервер UNIX за замовчуванням відображає uid 0 на виділене значення (UID_NOBODY), а також відображає список груп перед виконанням перевірки доступу. Серверна реалізація може забезпечити механізм зміни цього відображення. Це працює, за винятком кореневих файлових систем протоколу NFS версії 3 (потрібно для підтримки бездискового клієнта протоколу NFS версії 3), де неможливо уникнути доступу суперкористувача. Параметри експорту використовуються на сервері для обмеження набору клієнтів, яким дозволено доступ суперкористувача.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
                        
            
            <p class="P3" id="section_4.5">4.5 Дубльований кеш запитів</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Типова модель відновлення після збою протоколу NFS версії 3 використовує час очікування клієнта та повторну спробу для обробки збоїв сервера, мережевих розділів і втрачених відповідей сервера. Повторний запит називається дублікатом оригіналу.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   При використанні в контексті файлового сервера, термін "ідемпотентний" можна використовувати для розрізнення типів операцій. Ідемпотентний запит — це запит, який сервер може виконати більше одного разу з еквівалентними результатами (хоча насправді він може змінити, як побічний ефект, час доступу до файлу, скажімо, для READ). Деякі операції NFS явно неідемпотентні. Їх не можна повторно обробити без особливої уваги просто тому, що вони можуть закінчитися невдало, якщо їх спробувати вдруге. Наприклад запит CREATE можна використовувати для створення файлу, для якого власник не має дозволу на запис. Дублікат цього запиту не може бути виконаний, якщо оригінал виконано успішно. Так само файл можна видалити лише один раз.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Побічні ефекти, викликані виконанням повторюваного неідемпотентного запиту, можуть бути руйнівними (наприклад, операція скорочення, що спричиняє втрату запису). Поєднання дизайну без стану із загальним вибором ненадійного мережевого транспорту (UDP) передбачає можливість деструктивного відтворення неідемпотентних запитів. Хоча, якщо бути більш точним, це властивий дизайн без збереження стану протоколу NFS версії 3 на додачу до ненадійного механізму RPC, який дає можливість деструктивного повторного відтворення неідемпотентних запитів, оскільки навіть у реалізації протоколу NFS версії 3 над надійний транспорт, орієнтований на з’єднання, розрив з’єднання з автоматичним відновленням вимагає обробки повторного запиту (клієнт повторно передасть запит, а сервер має мати справу з потенційним дублікатом неідемпотентного запиту).</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Більшість реалізацій сервера протоколу NFS версії 3 використовують кеш останніх запитів (так званий кеш дублікатів запитів) для обробки дублікатів неідемпотентних запитів. Кеш дублікатів запитів забезпечує механізм короткочасної пам’яті, у якому початковий статус завершення запиту запам’ятовується, а операція виконується лише один раз. Якщо отримано дублікат цього запиту, повертається вихідний статус завершення.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Механізм кешу дублікатів запитів був корисним для зменшення руйнівних побічних ефектів, викликаних дублікатами запитів протоколу NFS версії 3. Цей механізм, однак, не гарантує від цих руйнівних побічних ефектів у всіх режимах відмови. Більшість серверів зберігають кеш дублікатів запитів у оперативній пам’яті, тому вміст буде втрачено, якщо сервер виходить з ладу. Виняток із цього може статися у підході використання резервного сервера високої доступності, де сама файлова система може використовуватися для спільного використання стану кешу дублікатів запитів. Навіть якщо кеш витримує перезавантаження сервера (або відновлення після відмови у випадку високої доступності), його ефективність залежить від його розміру. Розділ мережі може спричинити повторне використання запису кешу до того, як клієнт отримає відповідь на відповідний запит. Якщо це станеться, дублікат запиту буде оброблено як новий, можливо, з руйнівними побічними ефектами.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Гарний опис реалізації та використання кешу дублікатів запитів можна знайти в [Juszczak].</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            <p class="P3" id="section_4.6">4.6 Обробка компонента file name</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Серверні реалізації протоколу NFS версії 3 часто накладають обмеження на імена, які можна створити. Багато серверів також забороняють використовувати імена, які містять певні символи, наприклад роздільник компонентів шляху, який використовує операційна система сервера. Наприклад, файлова система UFS відхилить назву, яка містить "/", а "." і ".." розрізняються в UFS і не можуть бути вказані як ім'я під час створення об'єкта файлової системи. Точні значення статусу помилки, які повертаються для цих помилок, указано в описі кожного аргументу процедури. Значення (які відповідають практиці сервера протоколів NFS версії 2) не обов’язково є очевидними, а також не є послідовними від однієї процедури до іншої.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            <p class="P3" id="section_4.7">4.7 Синхронні операції модифікації</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Операції зміни даних у протоколі NFS версії 3 є синхронними. Коли процедура повертається до клієнта, клієнт може вважати, що операцію завершено, і всі дані, пов’язані із запитом, тепер у стабільному сховищі.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
                        
            
            <p class="P3" id="section_4.8">4.8 Стабільне зберігання</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Сервери протоколу NFS версії 3 повинні мати можливість відновлення без втрати даних після численних збоїв живлення (включно з каскадними збоями живлення, тобто кількох збоїв живлення у швидкій послідовності), збоїв операційної системи та апаратних збоїв компонентів, крім самого носія (наприклад, диск, енергонезалежна оперативна пам'ять).</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Деякі приклади стабільного сховища, допустимого для сервера FS, включають:</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   1. Фіксування даних на носії, тобто змінені дані були успішно записані на дисковий носій, наприклад, дискову пластину.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   2. Дисковий привід негайної відповіді з проміжним накопичувачем або системою безперебійного живлення (UPS) із живленням від батареї.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   3. Фіксування даних на сервері за допомогою проміжного зберігання з акумулятором та програмного забезпечення для відновлення.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   4. Фіксування кешу за допомогою системи безперебійного живлення (UPS) і програмного забезпечення для відновлення.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   І навпаки, наступне не є прикладом стабільного зберігання:</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   1. Дисковод із миттєвою відповіддю без проміжного накопичувача або системи безперебійного живлення (UPS) із живленням від батареї.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   2. Кешування без системи безперебійного живлення (UPS) і програмного забезпечення відновлення.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Єдиним винятком із цього (введеним у цій версії протоколу) є те, що описано в процедурі WRITE щодо обробки біта стабільності та використання процедури COMMIT. Це використання синхронної процедури COMMIT, яка забезпечує необхідну семантичну підтримку в протоколі NFS версії 3.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
                        
            <p class="P3" id="section_4.9">4.9 Пошук і розпізнавання імен</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Загальним запереченням проти протоколу NFS версії 3 є філософія покомпонентного LOOKUP клієнтом при розпізнаванні імені. Заперечення полягає в тому, що це неефективно, оскільки затримки для покомпонентного LOOKUP були б неприйнятними.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Практика впровадження вирішує це питання. Кеш імен, що забезпечує перетворення компонента для опису файлу, зберігається на клієнті для фактичних прямих викликів LOOKUP. Кеш підлягає параметрам тайм-ауту кешу, які пов’язують атрибути.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            
            <p class="P3" id="section_4.10">4.10 Адаптивна ретрансляція</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Більшість клієнтських реалізацій використовують або експоненціальну стратегію відстрочки до деякого максимального значення повторної передачі, або більш адаптивну стратегію, яка намагається уникнути перевантаження. Схеми уникнення перевантаження при повторній передачі запиту NFS моделюються на основі роботи, представленої в [Jacobson]. [Nowicki] і [Macklem] описують схеми уникнення перевантаження, які будуть застосовані до протоколу NFS через UDP.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            
            <p class="P3" id="section_4.11">4.11 Політика кешування</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Протокол NFS версії 3 не визначає політику кешування на клієнті чи сервері. Зокрема, немає підтримки суворої узгодженості кешу між клієнтом і сервером, а також між різними клієнтами. Дивіться [Kazar] для обговорення питань синхронізації кешу та механізмів у кількох розподілених файлових системах.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            
            <p class="P3" id="section_4.12">4.12 Стабільний запис проти нестабільного</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Установка поля stable в аргументах WRITE, яка визначає чи потрібно виконувати асинхронні запити WRITE, є простою у клієнті UNIX. Якщо клієнт протоколу NFS версії 3 отримує запит на запис, який не позначений як асинхронний, він повинен створити RPC зі stable значенням TRUE. Якщо запит позначено як асинхронний, RPC має бути згенеровано зі stable значенням FALSE. Якщо відповідь надходить із зафіксованим полем, встановленим у значення TRUE, клієнт повинен просто позначити запит на запис як виконаний, і подальші дії не потрібні. Якщо для параметра committed встановлено значення FALSE, що вказує на те, що буфер не було синхронізовано з диском сервера, клієнту потрібно буде позначити буфер певним чином, який вказує на те, що копія буфера знаходиться на сервері. І що нову копію не потрібно буде надсилати на сервер, але потрібне фіксування.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Зверніть увагу, що цей алгоритм вводить новий стан для буферів. Таким чином, тепер існує три стани для буферів. Буфер є "брудним", виконано, але потрібно зафіксувати, зроблено. Цей додатковий стан на клієнті, ймовірно, вимагатиме змін у системі за межами клієнта протоколу NFS версії 3.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Однією пропозицією, яку було відхилено, було додавання логічного аргументу фіксації до операції WRITE. Цей аргумент використовувався б для вказівки, чи повинен сервер виконати повну фіксацію файлу після виконання запису. Здається, це могло би бути корисним, якби клієнт знав, що він виконує останній запис у файл. Важко зрозуміти, як це можна було б використати, враховуючи існуючу клієнтську архітектуру.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Асинхронний запис відкриває вікно проблем, пов’язаних із спільним записом. Наприклад: клієнт A записує деякі дані асинхронно. Клієнт А все ще зберігає буфери в кеш-пам’яті, чекаючи, щоб зафіксувати їх пізніше. Клієнт Б зчитує змінені дані та записує їх назад на сервер. Після цього сервер виходить з ладу. Коли він відновлює роботу, клієнт A виконує операцію COMMIT, яка повертається з іншим файлом cookie та зміненими атрибутами. У цьому випадку коректною дією може бути як повторна передача кешованих буферів, так і не передача буферів. На жаль, клієнт A не може сказати напевно, тому йому потрібно буде повторно передати буфери, таким чином перезаписуючи зміни клієнта Б. На щастя, спільний доступ до запису зустрічається рідко, і рішення відповідає поточній ситуації спільного запису. Без використання блокування для синхронізації WRITE поведінка буде невизначеною.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   У реалізації сервера високої доступності (надлишкова система) існують два випадки, пов’язані зі зміною verf. Якщо реалізація сервера високої доступності не використовує схему спільної пам’яті, тоді verf має змінитися під час відновлення після відмови сервера, оскільки несинхронізовані дані недоступні для іншого процесора, і немає гарантії, що система, яка кешувала дані, змогла скинути їх до стабільного сховища перед виходом з ладу. Для безпеки клієнту потрібно буде повторно передати дані. У реалізації сервера високої доступності зі спільною пам’яттю verf не потрібно буде змінювати, оскільки сервер все ще матиме кешовані дані, доступні для скидання. Однак точна політика щодо verf у реалізації високої доступності спільної пам’яті залежить від розробника сервера.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
                        
            <p class="P3" id="section_4.13">4.13 32-розрядні клієнти/сервери та 64-розрядні клієнти/сервери</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   64-розрядна природа протоколу NFS версії 3 створює кілька проблем із сумісністю. Найпомітніші два – це невідповідні клієнти та сервери, тобто 32-розрядний клієнт і 64-розрядний сервер або 64-розрядний клієнт і 32-розрядний сервер.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Проблеми 64-розрядного клієнта та 32-розрядного сервера легко вирішити. Клієнт ніколи не зіткнеться з файлом, який він не зможе обробити. Якщо він надсилає запит на сервер, який сервер не може обробити, сервер повинен відхилити запит із відповідною помилкою.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   З проблемами 32-розрядного клієнта та 64-розрядного сервера впоратися набагато важче. У цій ситуації у сервера немає проблем, оскільки він може обробляти все, що може створити клієнт. Однак клієнт може зіткнутися з файлом, який він не може обробити. Клієнт не зможе обробити файл, розмір якого не може бути виражений у 32 бітах. Таким чином, клієнт не зможе належним чином декодувати розмір файлу в структурі локальних атрибутів. Крім того, файл може перевищити обмеження клієнта, поки клієнт отримує доступ до файлу.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Рішення цих проблем покладено на розсуд конкретного виконавця. Однак існує два загальних підходи до вирішення цієї ситуації. Розробник може вибрати між ними або взагалі винайти нове рішення.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Найпоширенішим рішенням для клієнта є заборона доступу до будь-якого файлу, розмір якого не може бути виражений у 32 бітах. Це, мабуть, найбезпечніше, але створює деяку дивну семантику, коли файл збільшується понад обмеження клієнта, поки цей клієнт до нього отримує доступ. Файл стає недоступним навіть під час доступу до нього.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Друге рішення полягає в тому, щоб клієнт перетворював будь-який розмір, більший, ніж розмір, який він може обробити, на максимальний розмір, який він може обробити. По суті, це обманює прикладну програму. Це дозволяє програмі отримати доступ до якомога більшої частини файлу, враховуючи обмеження на 32-бітове зміщення. Це усуває дивну семантику фактичного зникнення файлу після доступу до нього, але створює інші проблеми. Клієнт не зможе отримати доступ до всього файлу.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Наразі перше рішення є рекомендованим. Проте розробникам клієнтів рекомендується робити все можливе, щоб зменшити наслідки цієї ситуації.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            <hr>
            <p class="Pr_20_Text"> </p>







            <p class="P2" id="section_5">5 Додаток I: Протокол монтування (MOUNT)</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Зміни з протоколу NFS версії 2 на протокол NFS версії 3 вимагали внесення деяких змін у протокол MOUNT. Щоб задовольнити потреби протоколу NFS версії 3, була визначена нова версія протоколу MOUNT. Цей новий протокол задовольняє вимоги протоколу NFS версії 3 і відповідає деяким іншим поточним вимогам ринку.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>


            <p class="P3" id="section_5.1">5.1 Інформація RPC</p>
            <p class="Pr_20_Text"> </p>
            <p class="P3">5.1.1 Автентифікація</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Служба MOUNT у процедурі NULL використовує AUTH_NONE. Для всіх інших процедур використовуються AUTH_UNIX, AUTH_SHORT, AUTH_DES або AUTH_KERB. Інші типи автентифікації можуть підтримуватися в майбутньому.</p>
            <p class="Pr_20_Text"> </p>


            <p class="P3" id="section_5.1.2">5.1.2 Константи</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">    Це константи RPC, необхідні для виклику служби MOUNT. Вони подані в десятковому вигляді.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">       PROGRAM 100005</p>
            <p class="Pr_20_Text">       VERSION 3</p>
            <p class="Pr_20_Text"> </p>


            <p class="P3" id="section_5.1.3">5.1.3 Транспортна адреса</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">    Служба MOUNT зазвичай підтримується через протоколи TCP і UDP. У демона rpcbind слід запитати правильну транспортну адресу.</p>
            <p class="Pr_20_Text"> </p>


            <p class="P3" id="section_5.1.4">5.1.4 Розміри</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   const MNTPATHLEN = 1024;  /* Максимальна кількість байтів в імені шляху */</p>
            <p class="Pr_20_Text">   const MNTNAMLEN  = 255;   /* Максимальна кількість байтів в імені */</p>
            <p class="Pr_20_Text">   const FHSIZE3    = 64;    /* Максимальна кількість байтів в V3 файловому дескрипторі */</p>
            <p class="Pr_20_Text"> </p>


            <p class="P3" id="section_5.1.5">5.1.5 Основні типи даних</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   typedef opaque fhandle3&lt;FHSIZE3&gt;;</p>
            <p class="Pr_20_Text">   typedef string dirpath&lt;MNTPATHLEN&gt;;</p>
            <p class="Pr_20_Text">   typedef string name&lt;MNTNAMLEN&gt;;</p>
            <p class="Pr_20_Text">   enum mountstat3 {</p>
            <p class="Pr_20_Text">      MNT3_OK = 0,                 /* помилок не має */</p>
            <p class="Pr_20_Text">      MNT3ERR_PERM = 1,            /* не є власником */</p>
            <p class="Pr_20_Text">      MNT3ERR_NOENT = 2,           /* не існує такого файлу або директорії */</p>
            <p class="Pr_20_Text">      MNT3ERR_IO = 5,              /* I/O помилка */</p>
            <p class="Pr_20_Text">      MNT3ERR_ACCES = 13,          /* доступ заборонено */</p>
            <p class="Pr_20_Text">      MNT3ERR_NOTDIR = 20,         /* не є директорією */</p>
            <p class="Pr_20_Text">      MNT3ERR_INVAL = 22,          /* некоректний аргумент */</p>
            <p class="Pr_20_Text">      MNT3ERR_NAMETOOLONG = 63,    /* імʼя файла занадто довге */</p>
            <p class="Pr_20_Text">      MNT3ERR_NOTSUPP = 10004,     /* операція не підтримується */</p>
            <p class="Pr_20_Text">      MNT3ERR_SERVERFAULT = 10006  /* збій сервера */</p>
            <p class="Pr_20_Text">   };</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            
            <p class="P3" id="section_5.2">5.2 Процедури сервера</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   У наступних розділах описано процедури RPC, що надаються сервером протоколу MOUNT версії 3. Номер процедури RPC вказано у верхній частині сторінки з назвою та версією. СИНОПСИС містить назву процедури, список імен аргументів, список імен результатів, а потім оголошення аргументів XDR і оголошення результатів. Інформація в SYNOPSIS указана мовою опису даних RPC, як визначено в [RFC1014]. Розділ ОПИС описує, що має робити процедура та як використовуються її аргументи та результати. У розділі ПОМИЛКИ перелічено помилки, які повертаються для певних типів помилок. Розділ РЕАЛІЗАЦІЯ описує очікування того, як процедура працюватиме, та як її мають використовувати клієнти.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   program MOUNT_PROGRAM {</p>
            <p class="Pr_20_Text">        version MOUNT_V3 {</p>
            <p class="Pr_20_Text">            void      MOUNTPROC3_NULL(void)    = 0;</p>
            <p class="Pr_20_Text">            mountres3 MOUNTPROC3_MNT(dirpath)  = 1;</p>
            <p class="Pr_20_Text">            mountlist MOUNTPROC3_DUMP(void)    = 2;</p>
            <p class="Pr_20_Text">            void      MOUNTPROC3_UMNT(dirpath) = 3;</p>
            <p class="Pr_20_Text">            void      MOUNTPROC3_UMNTALL(void) = 4;</p>
            <p class="Pr_20_Text">            exports   MOUNTPROC3_EXPORT(void)  = 5;</p>
            <p class="Pr_20_Text">        } = 3;</p>
            <p class="Pr_20_Text">    } = 100005;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            <p class="P3" id="section_5.2.0">5.2.0 Процедура 0: NULL – нічого не робити</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   СИНОПСИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void MOUNTPROC3_NULL(void) = 0;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ОПИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Процедура NULL не виконує жодної роботи. Вoнa доступнa для тестування відповіді сервера та часу.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Важливо, щоб ця процедура не виконувала жодної роботи, щоб її можна було використовувати для вимірювання накладних витрат на виконання обробки запиту. Згідно з угодою, процедура NULL ніколи не повинна вимагати жодної автентифікації. Сервер може ігнорувати цю угоду в більш безпечній реалізації, коли відповідь на виклик процедури NULL підтверджує існування ресурсу для неавтентифікованого клієнта.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ПОМИЛКИ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Оскільки процедура NULL не приймає аргументів протоколу MOUNT і не повертає відповіді протоколу MOUNT, вона не може повернути помилку протоколу MOUNT. Однак можливо, що деякі серверні реалізації можуть повертати помилки RPC на основі вимог безпеки та автентифікації.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            <p class="P3" id="section_5.2.1">5.2.1 Procedure 1: MNT - Додати запис монтування</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   СИНОПСИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      mountres3 MOUNTPROC3_MNT(dirpath) = 1;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      struct mountres3_ok {</p>
            <p class="Pr_20_Text">           fhandle3   fhandle;</p>
            <p class="Pr_20_Text">           int        auth_flavors&lt;&gt;;</p>
            <p class="Pr_20_Text">      };</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      union mountres3 switch (mountstat3 fhs_status) {</p>
            <p class="Pr_20_Text">      case MNT_OK:</p>
            <p class="Pr_20_Text">           mountres3_ok  mountinfo;</p>
            <p class="Pr_20_Text">      default:</p>
            <p class="Pr_20_Text">           void;</p>
            <p class="Pr_20_Text">      };</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ОПИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Процедура MNT відображає шлях на сервері до файлового дескриптора. Шлях — це рядок ASCII, який описує директорію на сервері. Якщо виклик успішний (MNT3_OK), сервер повертає файловий дескриптор протоколу NFS версії 3 і вектор варіантів автентифікації RPC, які підтримуються використанням клієнтом файлового дескриптора (або будь-яких файлових дескрипторів, похідних від нього). Параметри автентифікації визначено в розділі 7.2 і розділі 9 [RFC1057].</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Якщо mountres3.fhs_status має значення MNT3_OK, тоді mountres3.mountinfo містить файловий дескриптор для каталогу та список прийнятних варіантів автентифікації. Цей файловий дескриптор можна використовувати лише в протоколі NFS версії 3. Ця процедура також призводить до того, що сервер додає до свого списку монтування новий запис про те, що цей клієнт змонтував директорію. Для виконання потрібна автентифікація AUTH_UNIX або краща.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ПОМИЛКИ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      MNT3ERR_NOENT</p>
            <p class="Pr_20_Text">      MNT3ERR_IO</p>
            <p class="Pr_20_Text">      MNT3ERR_ACCES</p>
            <p class="Pr_20_Text">      MNT3ERR_NOTDIR</p>
            <p class="Pr_20_Text">      MNT3ERR_NAMETOOLONG</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            
            <p class="P3" id="section_5.2.2">5.2.2 Procedure 2: DUMP - Повернути записи монтування</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   СИНОПСИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      mountlist MOUNTPROC3_DUMP(void) = 2;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      typedef struct mountbody *mountlist;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      struct mountbody {</p>
            <p class="Pr_20_Text">           name       ml_hostname;</p>
            <p class="Pr_20_Text">           dirpath    ml_directory;</p>
            <p class="Pr_20_Text">           mountlist  ml_next;</p>
            <p class="Pr_20_Text">      };</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ОПИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Процедура DUMP повертає список віддалено змонтованих файлових систем. Список монтування містить один запис для кожної пари імені хоста клієнта та каталогу.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Цей список отримується зі списку клієнтів, який зберігається на сервері, які запитали файлові дескриптори за допомогою процедури MNT. Записи видаляються з цього списку лише тоді, коли клієнт викликає процедуру UMNT або UMNTALL. Записи можуть стати застарілими, якщо клієнт аварійно завершує роботу та не виконує виклики UMNT для всіх файлових систем, які він попередньо змонтував, або UMNTALL для видалення всіх записів, які існували для нього на сервері.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ПОМИЛКИ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Немає помилок протоколу MOUNT, які можуть бути повернуті цією процедурою. Однак помилки RPC можуть повертатися для автентифікації або інших помилок RPC.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            
            <p class="P3" id="section_5.2.3">5.2.3 Procedure 3: UMNT - Видалити запис монтування</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   СИНОПСИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void MOUNTPROC3_UMNT(dirpath) = 3;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ОПИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Процедура UMNT видаляє запис зі списку монтування для директорії, який раніше був субʼєктом виклику MNT від цього клієнта. Потрібна автентифікація AUTH_UNIX або краща.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Як правило, серверні реалізації підтримують список клієнтів, які мають змонтовані файлові системи. Раніше цей список використовувався для інформування клієнтів про те, що сервер буде закрито.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">    ПОМИЛКИ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">       Немає помилок протоколу MOUNT, які можуть бути повернуті цією процедурою. Однак помилки RPC можуть повертатися для автентифікації або інших помилок RPC.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            <p class="P3" id="section_5.2.4">5.2.4 Procedure 4: UMNTALL - Видалити усі записи монтування</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   СИНОПСИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void MOUNTPROC3_UMNTALL(void) = 4;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ОПИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Процедура UMNTALL видаляє всі записи монтування для цього клієнта, попередньо записані викликами MNT. Потрібна автентифікація AUTH_UNIX або краща.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Цю процедуру слід використовувати клієнтам, коли вони відновлюються після завершення роботи системи. Якщо клієнт не зміг успішно відключити всі свої файлові системи перед завершенням роботи, або клієнт зазнав краху через програмну чи апаратну проблему, можливо, є сервери, які все ще мають записи монтування для цього клієнта. Це простий спосіб для клієнта повідомити всім серверам одночасно, що він не має змонтованих файлових систем. Однак, оскільки ця процедура зазвичай реалізується за допомогою широкомовного RPC, вона має лише обмежену корисність.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ПОМИЛКИ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Немає помилок протоколу MOUNT, які можуть бути повернуті цією процедурою. Однак помилки RPC можуть повертатися для автентифікації або інших помилок RPC.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            
            <p class="P3" id="section_5.2.5">5.2.5 Procedure 5: EXPORT - Повернути список експорту</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   СИНОПСИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      exports MOUNTPROC3_EXPORT(void) = 5;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      typedef struct groupnode *groups;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      struct groupnode {</p>
            <p class="Pr_20_Text">           name     gr_name;</p>
            <p class="Pr_20_Text">           groups   gr_next;</p>
            <p class="Pr_20_Text">      };</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      typedef struct exportnode *exports;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      struct exportnode {</p>
            <p class="Pr_20_Text">           dirpath  ex_dir;</p>
            <p class="Pr_20_Text">           groups   ex_groups;</p>
            <p class="Pr_20_Text">           exports  ex_next;</p>
            <p class="Pr_20_Text">      };</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ОПИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Процедура EXPORT повертає перелік усіх експортованих файлових систем і перелік клієнтів, яким дозволено монтувати кожну з них. Імена в переліку груп залежать від реалізації і не можуть бути безпосередньо інтерпретовані клієнтами. Ці імена можуть представляти хости або групи хостів.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Ця процедура зазвичай повертає вміст списку спільних або експортованих файлових систем. Це файлові системи, доступні для клієнтів протоколу NFS версії 3.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ПОМИЛКИ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Немає помилок протоколу MOUNT, які можуть бути повернуті цією процедурою. Однак помилки RPC можуть повертатися для автентифікації або інших помилок RPC.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            <hr>
            <p class="Pr_20_Text"> </p>
            
            
            
            
        <p class="P2" id="section_6">6 Додаток II: Протокол менеджера блокувань</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Оскільки протокол NFS версії 2, а також протокол NFS версії 3 не має режиму, для підтримки блокування файлів, підключених до NFS, потрібен додатковий протокол Network Lock Manager (NLM). Протокол NLM версії 3, який використовується з протоколом NFS версії 2, задокументовано в [X/OpenNFS].</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Деякі зміни у протоколі NFS версії 3 вимагають нової версії протоколу NLM. Цей новий протокол є протоколом NLM версії 4. У наведеній нижче таблиці підсумовано відповідність між версіями протоколу NFS і протоколу NLM.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">        Сумісність протоколів NFS і NLM</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">                +---------+---------+</p>
        <p class="Pr_20_Text">                | NFS     | NLM     |</p>
        <p class="Pr_20_Text">                | Версія  | Версія  |</p>
        <p class="Pr_20_Text">                +===================+</p>
        <p class="Pr_20_Text">                |    2    |   1,3   |</p>
        <p class="Pr_20_Text">                +---------+---------+</p>
        <p class="Pr_20_Text">                |    3    |    4    |</p>
        <p class="Pr_20_Text">                +---------+---------+</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   У цьому додатку розглядаються лише відмінності між протоколом NLM версії 3 і протоколом NLM версії 4. Як і в протоколі NFS версії 3, майже всі назви в протоколі NLM версії 4 були змінені, щоб включити номер версії. У цьому додатку не розглядаються зміни, які складаються лише зі зміни імені.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
            
            
        <p class="P3" id="section_6.1">6.1 Інформація RPC</p>
        <p class="Pr_20_Text"> </p>
            
        <p class="P3" id="section_6.1.1">6.1.1 Автентифікація</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Служба NLM використовує AUTH_NONE у процедурі NULL. Для всіх інших процедур використовуються AUTH_UNIX, AUTH_SHORT, AUTH_DES і AUTH_KERB. Інші типи автентифікації можуть підтримуватися в майбутньому.</p>
        <p class="Pr_20_Text"> </p>
            
            
        <p class="P3" id="section_6.1.2">6.1.2 Константи</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">    Це константи RPC, необхідні для виклику служби NLM. Вони подані в десятковому вигляді.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">       PROGRAM 100021</p>
        <p class="Pr_20_Text">       VERSION 4</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
            
            
        <p class="P3" id="section_6.1.3">6.1.3 Транспортна адреса</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Служба NLM зазвичай підтримується через протоколи TCP і UDP. У демона rpcbind слід запитати правильну транспортну адресу.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
            
            
        <p class="P3" id="section_6.1.4">6.1.4 Основні типи даних</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   uint64</p>
        <p class="Pr_20_Text">      typedef unsigned hyper uint64;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   int64</p>
        <p class="Pr_20_Text">      typedef hyper int64;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   uint32</p>
        <p class="Pr_20_Text">      typedef unsigned long uint32;</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   int32</p>
        <p class="Pr_20_Text">      typedef long int32;   </p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Ці типи є новими для протоколу NLM версії 4. Вони такі ж, як і в протоколі NFS версії 3.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   nlm4_stats</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      enum nlm4_stats {</p>
        <p class="Pr_20_Text">         NLM4_GRANTED = 0,</p>
        <p class="Pr_20_Text">         NLM4_DENIED = 1,</p>
        <p class="Pr_20_Text">         NLM4_DENIED_NOLOCKS = 2,</p>
        <p class="Pr_20_Text">         NLM4_BLOCKED = 3,</p>
        <p class="Pr_20_Text">         NLM4_DENIED_GRACE_PERIOD = 4,</p>
        <p class="Pr_20_Text">         NLM4_DEADLCK = 5,</p>
        <p class="Pr_20_Text">         NLM4_ROFS = 6,</p>
        <p class="Pr_20_Text">         NLM4_STALE_FH = 7,</p>
        <p class="Pr_20_Text">         NLM4_FBIG = 8,</p>
        <p class="Pr_20_Text">         NLM4_FAILED = 9</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Nlm4_stats вказує на успішність або невдачу виклику. Ця версія містить кілька нових кодів помилок, щоб клієнти могли надавати додаткам точнішу інформацію про помилки.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   NLM4_GRANTED</p>
        <p class="Pr_20_Text">      Виклик завершено успішно.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   NLM4_DENIED</p>
        <p class="Pr_20_Text">      Виклик не вдався. Для спроб встановити блокування цей статус означає, що якщо клієнт повторить виклик пізніше, це може вдатися.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   NLM4_DENIED_NOLOCKS</p>
        <p class="Pr_20_Text">      Виклик не вдався, оскільки сервер не зміг виділити необхідні ресурси.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   NLM4_BLOCKED</p>
        <p class="Pr_20_Text">      Вказує, що запит на блокування не може бути задоволений негайно. Сервер надішле зворотний виклик NLMPROC4_GRANTED клієнту, коли буде надано блокування.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   NLM4_DENIED_GRACE_PERIOD</p>
        <p class="Pr_20_Text">      Виклик не вдався, оскільки сервер відновлює старі блокування після перезавантаження та ще не готовий відновити звичайне обслуговування.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   NLM4_DEADLCK</p>
        <p class="Pr_20_Text">      Запит не міг бути виконаним, і блокування спричинило б взаємоблокування (deadlock).</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   NLM4_ROFS</p>
        <p class="Pr_20_Text">      Виклик не було виконано, оскільки віддалена файлова система доступна лише для читання. Наприклад, деякі серверні реалізації можуть не підтримувати ексклюзивне блокування файлових систем, доступних лише для читання.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   NLM4_STALE_FH</p>
        <p class="Pr_20_Text">      Виклик не було виконано, оскільки він використовує недійсний файловий дескриптор. Це може статися, якщо файл було видалено або якщо доступ до файлу було скасовано на сервері.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   NLM4_FBIG</p>
        <p class="Pr_20_Text">      Виклик не було виконано, оскільки вказано довжину або зсув, що перевищує діапазон, підтримуваний сервером.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   NLM4_FAILED</p>
        <p class="Pr_20_Text">      Виклик не вдався з якоїсь причини, якої ще не зазначено. Клієнт повинен сприймати цей статус як натяк, щоб не повторювати запит.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   nlm4_holder</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct nlm4_holder {</p>
        <p class="Pr_20_Text">           bool     exclusive;</p>
        <p class="Pr_20_Text">           int32    svid;</p>
        <p class="Pr_20_Text">           netobj   oh;</p>
        <p class="Pr_20_Text">           uint64   l_offset;</p>
        <p class="Pr_20_Text">           uint64   l_len;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Ця структура вказує на власника блокування. Ексклюзивне поле вказує, чи має власник ексклюзивну або спільну блокировку. Поле svid визначає процес, який утримує блокування. Поле oh — це непрозорий об’єкт, який ідентифікує хост або процес, який утримує блокування. Поля l_len і l_offset визначають заблоковану область. Єдина відмінність між протоколом NLM версії 3 і протоколом NLM версії 4 полягає в тому, що в протоколі NLM версії 3 ширина полів l_len і l_offset становить 32 біти, тоді як у протоколі NLM версії 4 вони мають ширину 64 біти.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   nlm4_lock</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct nlm4_lock {</p>
        <p class="Pr_20_Text">         string   caller_name&lt;LM_MAXSTRLEN&gt;;</p>
        <p class="Pr_20_Text">         netobj   fh;</p>
        <p class="Pr_20_Text">         netobj   oh;</p>
        <p class="Pr_20_Text">         int32    svid;</p>
        <p class="Pr_20_Text">         uint64   l_offset;</p>
        <p class="Pr_20_Text">         uint64   l_len;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Ця структура описує запит на блокування. Поле caller_name визначає хост, який робить запит. Поле fh визначає файл, який потрібно заблокувати. Поле oh є непрозорим об’єктом, який ідентифікує хост або процес, який робить запит, а поле svid ідентифікує процес, який робить запит. Поля l_offset і l_len визначають область файлу, яку контролює блокування. l_len 0 означає "до кінця файлу".</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Існують дві відмінності між протоколом NLM версії 3 і версіями протоколу NLM версії 4 цієї структури. По-перше, у протоколі NLM версії 3 довжина та зсув мають ширину 32 біти, тоді як у протоколі NLM версії 4 вони мають ширину 64 біти. По-друге, у протоколі NLM версії 3 файловий дескриптор — це файловий дескриптор фіксованої довжини протоколу NFS версії 2, який кодується як кількість байтів, за якою йде масив байтів. У протоколі NFS версії 3 файловий дескриптор вже має змінну довжину, тому він копіюється безпосередньо в поле fh. Тобто перші чотири байти поля fh збігаються з кількістю байтів у протоколі NFS версії 3 nfs_fh3. Решта поля fh містить масив байтів із протоколу NFS версії 3 nfs_fh3.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   nlm4_share</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">      struct nlm4_share {</p>
        <p class="Pr_20_Text">         string      caller_name&lt;LM_MAXSTRLEN&gt;;</p>
        <p class="Pr_20_Text">         netobj      fh;</p>
        <p class="Pr_20_Text">         netobj      oh;</p>
        <p class="Pr_20_Text">         fsh4_mode   mode;</p>
        <p class="Pr_20_Text">         fsh4_access access;</p>
        <p class="Pr_20_Text">      };</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text">   Ця структура використовується для підтримки обміну файлами DOS. Поле caller_name визначає хост, який робить запит. Поле fh визначає файл, з яким потрібно працювати. Поле oh — це непрозорий об’єкт, який ідентифікує хост або процес, який робить запит. Поля mode та access вказують режими обміну файлами та доступу. Кодування fh — це кількість байтів, за якою слідує масив байтів файлового дескриптора. Для більш детальної інформації дивись опис nlm4_lock.</p>
        <p class="Pr_20_Text"> </p>
        <p class="Pr_20_Text"> </p>
            
            
            
            <p class="P3" id="section_6.2">6.2 Процедури NLM</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Процедури у протоколі NLM версії 4 семантично такі ж, як і в протоколі NLM версії 3. Єдина семантична відмінність полягає в додаванні процедури NULL, яка може бути використана для перевірки відповідності сервера. Назви процедур із суфіксами _MSG і _RES позначають асинхронні повідомлення; для них порожня (void) відповідь означає відсутність відповіді. Синтаксична зміна полягає в тому, що процедури були перейменовані, щоб уникнути конфліктів назв зі значеннями nlm4_stats. Таким чином, визначення процедури виглядає наступним чином.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   version NLM4_VERS {</p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_NULL(void)                  = 0;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      nlm4_testres</p>
            <p class="Pr_20_Text">         NLMPROC4_TEST(nlm4_testargs)         = 1;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      nlm4_res</p>
            <p class="Pr_20_Text">         NLMPROC4_LOCK(nlm4_lockargs)         = 2;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      nlm4_res</p>
            <p class="Pr_20_Text">         NLMPROC4_CANCEL(nlm4_cancargs)       = 3;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      nlm4_res</p>
            <p class="Pr_20_Text">         NLMPROC4_UNLOCK(nlm4_unlockargs)     = 4;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      nlm4_res</p>
            <p class="Pr_20_Text">         NLMPROC4_GRANTED(nlm4_testargs)      = 5;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_TEST_MSG(nlm4_testargs)     = 6;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_LOCK_MSG(nlm4_lockargs)     = 7;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_CANCEL_MSG(nlm4_cancargs)   = 8;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_UNLOCK_MSG(nlm4_unlockargs) = 9;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_GRANTED_MSG(nlm4_testargs) = 10;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_TEST_RES(nlm4_testres)     = 11;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_LOCK_RES(nlm4_res)         = 12;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_CANCEL_RES(nlm4_res)       = 13;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_UNLOCK_RES(nlm4_res)       = 14;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_GRANTED_RES(nlm4_res)      = 15;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      nlm4_shareres</p>
            <p class="Pr_20_Text">         NLMPROC4_SHARE(nlm4_shareargs)      = 20;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      nlm4_shareres</p>
            <p class="Pr_20_Text">         NLMPROC4_UNSHARE(nlm4_shareargs)    = 21;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      nlm4_res</p>
            <p class="Pr_20_Text">         NLMPROC4_NM_LOCK(nlm4_lockargs)     = 22;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void</p>
            <p class="Pr_20_Text">         NLMPROC4_FREE_ALL(nlm4_notify)      = 23;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      } = 4;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
                        
            
            <p class="P3" id="section_6.2.0">6.2.0 Procedure 0: NULL - Нічого не робити (do nothing)</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   СИНОПСИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      void NLMPROC4_NULL(void) = 0;</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ОПИС</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Процедура NULL нічого не робить. Вона доступна у всіх службах RPC, щоб дозволити тестувати відповіді сервера та витрачений час на відповідь.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   РЕАЛІЗАЦІЯ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Важливо, щоб ця процедура зовсім нічого не робила, щоб її можна було використовувати для вимірювання накладних витрат на обслуговування обробки запиту. Згідно з угодою, процедура NULL ніколи не повинна вимагати жодної автентифікації.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   ПОМИЛКИ</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">      Можливо, що деякі серверні реалізації можуть повертати помилки RPC на основі вимог безпеки та автентифікації.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            
            
            
            <p class="P3" id="section_6.3">6.3 Проблеми впровадження</p>
            <p class="Pr_20_Text"> </p>
            <p class="P3">6.3.1 64-бітна довжина та зсуви</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Деякі сервери протоколу NFS версії 3 можуть підтримувати лише запити, де зсув або довжина файлу вміщується в 32 біти або менше. Для цих серверів менеджер блокувань матиме таке ж обмеження. Якщо такий менеджер блокувань отримує запит, який він не може обробити (оскільки зсув або довжина використовує більше 32 бітів), він повинен повернути помилку NLM4_FBIG.</p>
            <p class="Pr_20_Text"> </p>
            
            
            <p class="P3" id="section_6.3.2">6.3.2 Файлові дескриптори</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Зміна формату опису файлу з протоколу NFS версії 2 на протокол NFS версії 3 ускладнює диспетчер блокувань. По-перше, менеджеру блокувань потрібен якийсь спосіб визначити, коли файловий дескриптор протоколу NFS версії 2 посилається на той самий файл, що й файловий дескриптор протоколу NFS версії 3. (Це припускається, якщо диспетчер блокувань підтримує як клієнтів протоколу NLM версії 3, так і клієнтів протоколу NLM версії 4.) По-друге, якщо диспетчер блокувань запускає файловий дескриптор через функцію хешування, то їй може доведеться перейти до роботи з файловими дескрипторами NFS протоколу версії 3 так, як  вона працює з файловими дескрипторами протоколу NFS версії 2.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            <hr>
            <p class="Pr_20_Text"> </p>
            
            
            
            
                        
            <p class="P2" id="section_7">7.0 Додаток III: Бібліографія</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [Corbin] Corbin, John, "The Art of Distributed Programming-Programming Techniques for Remote Procedure Calls." Springer-Verlag, New York, New York. 1991.  Основний опис RPC і XDR і як програмувати розподілені програми з їх використанням.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [Glover] Glover, Fred, "TNFS Protocol Specification", Trusted System Interest Group.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [Israel] Israel, Robert K., Sandra Jett, James Pownell, George M. Ericson, "Eliminating Data Copies in                UNIX-based NFS Servers," Uniforum Conference Proceedings, San Francisco, CA, February 27 - March 2, 1989. Описує два методи зменшення кількості копій даних у коді сервера NFS.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [Jacobson] Jacobson, V., "Congestion Control and Avoidance," Proc. ACM SIGCOMM `88, Stanford, CA, August 1988. Документ описує вдосконалення протоколу TCP, яке дозволяє використовувати його в глобальних мережах і через шлюзи, що з’єднують мережі різної потужності. Ця робота стала відправною точкою для роботи над динамічною ретрансляцією NFS.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [Juszczak] Juszczak, Chet, "Improving the Performance and Correctness of an NFS Server," USENIX Conference Proceedings, USENIX Association, Berkeley, CA, June 1990, pages 53-63.  Описує реалізацію кешу відповідей, яка дозволяє уникнути роботи по обробці дублікатів запитів на сервері. Що ще                важливіше, хоч і вказано як побічний ефект, кеш відповідей допомагає уникнути руйнівного повторного застосування неідемпотентних операцій — покращуючи коректність.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [Kazar] Kazar, Michael Leon, "Synchronization and Caching Issues in the Andrew File System," USENIX Conference Proceedings, USENIX Association, Berkeley, CA, Dallas Winter 1988, pages 27-36. Опис схеми узгодженості кешу в AFS. Відмінності від інших розподілених файлових систем.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [Macklem] Macklem, Rick, "Lessons Learned Tuning the 4.3BSD Reno Implementation of the NFS Protocol", Winter USENIX Conference Proceedings, USENIX Association, Berkeley, CA, January 1991.  Описує роботу над продуктивністю під час налаштування реалізації NFS 4.3BSD Reno. Описує підвищення продуктивності (зменшення навантаження ЦП) через усунення копій даних.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [Mogul]  Mogul, Jeffrey C., "A Recovery Protocol for NFS", USENIX File System Workshop Proceedings, Ann Arbor, MI, USENIX Association, Berkeley, CA, May 1992.  Друга стаття про Spritely NFS, яка пропонує схему на основі оренди для відновлення стану протоколу узгодженості.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [Nowicki] Nowicki, Bill, "Transport Issues in the Network File System" ACM SIGCOMM newsletter Computer Communication Review, April 1989.  Короткий опис основи для роботи з динамічною ретрансляцією.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [Pawlowski] Pawlowski, Brian, Ron Hixon, Mark Stein, Joseph Tumminaro, "Network Computing in the UNIX and IBM Mainframe Environment," Uniforum `89 Conf.Proc., (1989) Опис реалізації NFS сервера впровадженого для операційної системи IBM MVS.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [RFC1014] Sun Microsystems, Inc., "XDR: External Data Representation Standard", RFC 1014, Sun Microsystems, Inc., June 1987. Специфікація канонічного формата для обміну даними, з використанням RPC.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [RFC1057] Sun Microsystems, Inc., "RPC: Remote rocedure Call Protocol Specification", RFC 1057, Sun Microsystems, Inc., June 1988. Специфікація "Remote procedure protocol".</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [RFC1094] Sun Microsystems, Inc., "Network Filesystem Specification", RFC 1094, Sun Microsystems, Inc., March 1989.  Специфікація NFS протоколу версії 2.</p>
            <p class="Pr_20_Text">   </p>
            <p class="Pr_20_Text">   [Sandberg] Sandberg, R., D. Goldberg, S. Kleiman, D. Walsh, B.  Lyon, "Design and Implementation of the Sun Network Filesystem," USENIX Conference Proceedings, USENIX Association, Berkeley, CA, Summer 1985. Основний документ, що описує реалізацію протоколу NFS версії 2 у SunOS, а також обговорює мету, специфікацію протоколу та компроміси.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [Srinivasan] Srinivasan, V., Jeffrey C. Mogul, "Spritely NFS:  Implementation and Performance of Cache Consistency Protocols", WRL Research Report 89/5, Digital Equipment Corporation Western Research Laboratory, 100 Hamilton Ave., Palo Alto, CA, 94301, May 1989.  Ця стаття аналізує ефект застосування протоколу узгодженості, подібного до Sprite, до стандартної у NFS. Питання відновлення у середовищі зі збереженням стану висвітлюються в [Mogul].</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [X/OpenNFS] X/Open Company, Ltd., X/Open CAE Specification: Protocols for X/Open Internetworking: XNFS, X/Open Company, Ltd., Apex Plaza, Forbury Road, Reading Berkshire, RG1 1AX, United Kingdom. Це незамінний довідник по протоколу NFS версії 2 і супутніх протоколів, включаючи Lock Manager і Portmapper.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   [X/OpenPCNFS] X/Open Company, Ltd., X/Open CAE Specification: Protocols for X/Open Internetworking: (PC)NFS, Developer's Specification, X/Open Company, Ltd., Apex Plaza, Forbury Road, Reading Berkshire, RG1 1AX, United Kingdom, 1991.  This is an indispensable reference for NFS version 2 protocol and accompanying protocols, including the Lock Manager and the Portmapper.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>



            <p class="P2" id="section_8">8. Міркування щодо безпеки</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Оскільки конфіденційні файли можуть передаватися або отримуватися від сервера за допомогою протоколу NFS, проблеми автентифікації, конфіденційності та цілісності даних повинні вирішуватися за допомогою реалізації цього протоколу.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Як і в попередній версії протоколу (версія 2), NFS версії 3 покладається на положення автентифікації підтримуваного протоколу RPC [RFC1057] і припускає, що конфіденційність і цілісність даних забезпечуються базовими транспортними рівнями, доступними в кожній реалізації протоколу. Див. розділ 4.4 для обговорення прав доступу до файлів.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>


            <p class="P2" id="section_9">9. Подяки</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">    Цей опис протоколу взято з оригінального документа, написаного Брайаном Павловським і переглянутого Пітером Штаубахом. Цей протокол є результатом спільних зусиль Джеффа Арнольда, Брента Каллагена, Джона Корбіна, Фреда Гловера, Чета Ющака, Майка Ейслера, Джона Гіллоно, Дейва Хітца, Майка Купфера, Ріка Маклема, Рона Мінніха, Браяна Павловскі, Девід Робінсон, Расті Сендберг, Крейг Шемп, Спенсер Шеплер, Карл Сміт, Марк Стайн, Пітер Стаубах, Том Телпі, Роб Терлоу та Марк Віттл.</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>




            <p class="P2" id="section_10">10. Адреси авторів</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Надсилайте коментарі щодо цього протоколу на адресу:</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   nfs3@eng.sun.com</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Brent Callaghan</p>
            <p class="Pr_20_Text">   Sun Microsystems, Inc.</p>
            <p class="Pr_20_Text">   2550 Garcia Avenue</p>
            <p class="Pr_20_Text">   Mailstop UMTV05-44</p>
            <p class="Pr_20_Text">   Mountain View, CA 94043-1100</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Phone: 1-415-336-1051</p>
            <p class="Pr_20_Text">   Fax:   1-415-336-6015</p>
            <p class="Pr_20_Text">   EMail: brent.callaghan@eng.sun.com</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Brian Pawlowski</p>
            <p class="Pr_20_Text">   Network Appliance Corp.</p>
            <p class="Pr_20_Text">   319 North Bernardo Ave.</p>
            <p class="Pr_20_Text">   Mountain View, CA 94043</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Phone: 1-415-428-5136</p>
            <p class="Pr_20_Text">   Fax:   1-415-428-5151</p>
            <p class="Pr_20_Text">   EMail: beepy@netapp.com</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Peter Staubach</p>
            <p class="Pr_20_Text">   Sun Microsystems, Inc.</p>
            <p class="Pr_20_Text">   2550 Garcia Avenue</p>
            <p class="Pr_20_Text">   Mailstop UMTV05-44</p>
            <p class="Pr_20_Text">   Mountain View, CA 94043-1100</p>
            <p class="Pr_20_Text"> </p>
            <p class="Pr_20_Text">   Phone: 1-415-336-5615</p>
            <p class="Pr_20_Text">   Fax:   1-415-336-6015</p>
            <p class="Pr_20_Text">   EMail: peter.staubach@eng.sun.com</p>
</body>

</html>
